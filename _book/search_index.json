[["data-management-databases-and-organizations.html", "Data Management: Databases and Organizations", " Data Management: Databases and Organizations Open Edition Richard T. Watson Department of MIS Terry is College of Business The University of Georgia Release date 2022-05-30 The online version of this book is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License CC BY-NC-SA 4.0. "],["preface.html", "Preface 0.1 Editors Note - This is the original preface of the text written by the author “Richard Watson”. I am leaving this preface in place to keep the specific acknowledgements made in this document. Not all of the content in this preface applies to this version of the text for the SQL for Data Analytics course. Supplements Acknowledgments", " Preface 0.1 Editors Note - This is the original preface of the text written by the author “Richard Watson”. I am leaving this preface in place to keep the specific acknowledgements made in this document. Not all of the content in this preface applies to this version of the text for the SQL for Data Analytics course. This is not your traditional database textbook. It differs in three fundamental ways. First, it is deeper than most database books in its coverage of data modeling and SQL. The market seeks graduates who have these fundamental skills. Time and again, students who have completed my data management class have told me how these skills have been invaluable in their first and subsequent jobs. The book places great emphasis on the core skills of data management. Consequently, there is a better match between the skills you develop and those the market needs. This means you will find this text highly relevant. Second, the treatments of data modeling and SQL are intertwined because my database teaching experience indicates that students more readily understand the purpose of data modeling when they grasp the long-term goal—querying a well-designed relational database. The double helix, upward, intertwined, spiraling of data modeling and SQL is a unique pedagogical feature. Classroom testing indicates it is a superior method of teaching compared to handling data modeling and SQL separately. You will quickly understand the reason for data modeling and appreciate why it is a valuable skill. Also, rapid exposure to SQL means you gain hands-on experience more quickly. Third, the book is broader than most database books. Databases are one component of an expansive organizational memory. You need to develop a wide perspective of data management if you are to comprehend fully the organizational role of information systems. In essence, the book is deeper where it matters—data modeling and SQL—and broader to give you a managerial outlook and an understanding of the latest technological advancements. Information is a key resource for modern organizations. It is a critical input to managerial tasks. Because managers need high-quality information to manage change in a turbulent, global environment, nearly every organizations has established systems for storing and retrieving data, the raw material of information. These storage and retrieval systems are an organization’s memory. The organization relies on them, just as individuals rely on their personal memory, to be able to continue as a going concern. The central concern of information systems management is to design, build, and maintain information delivery systems. Information systems managemers needs to discover their organization’s information requirements, which includes the needs of its customers, so that it can design systems to serve these demands. It must merge a system’s design and information technology to build applications that provide the organization and its customers with data in a timely manner, appropriate formats, and at convenient locations. Furthermore, it must manage applications so they evolve to meet changing needs, continue to operate under adverse conditions, and are protected from unauthorized access. An information delivery system has two components: data and processes. This book concentrates on data, which is customarily thought of as a database. I deliberately set out to extend this horizon, however, by including all forms of organizational data stores because I believe you need to understand the role of data management that is aligned with current practice. In my view, data management is the design and maintenance of computer-based organizational memory. Thus, you will find chapters on XML and organizational intelligence technologies. The decision to start the book with a managerial perspective arises from the observation that successful information systems practice is based on matching managerial needs, social system constraints, and technical opportunities in an ecologically sound way. I want you to appreciate the big picture before you become immersed in the intricacies of data modeling and SQL. The second section of the book provides in-depth coverage of data modeling and SQL. Data modeling is the foundation of database quality. A solid grounding in data modeling principles and extensive practice are necessary for successful database design. In addition, this section exposes you to the full power of SQL. I intend this book to be a long-term investment. There are useful reference sections for data modeling and SQL. The data modeling section details the standard structures and their relational mappings. The SQL section contains an extensive list of queries that serves as a basis for developing other SQL queries. The purpose of these sections is to facilitate pattern matching. For example, if you have an SQL query that is similar to a previous problem you can rapidly search the SQL reference section to find the closest match. You can then use the model answer as a guide to formulating the SQL query for the problem at hand. These reference sections are another unique teaching feature that will serve you well during the course and in your career. The third section has chapters on R, a statistics and graphics package, which provides the foundation necessary for the chapters on data visualization, text mining, cluster computing, and dashboards. These chapters provide you with the skills they need to work in topical areas such as data analytics. The third section, Advanced Data Management, which also covers spatial and temporal data, XML, and organizational intelligence, and greaph databases The fourth and final section examines the management of organizational data stores. It covers data structures and storage, data processing architectures, SQL and Java, data integrity, and data administration. As a result of completing this text you will have a broad, managerial perspective of an organization’s need for a memory; be able to design and create a relational database; be able to formulate complex SQL queries; be able to use R to create data visualizations, mine text data, write an R script for big data problems, and create dashboards; understand the purpose of XML and be able to design an XML schema, prepare an XML document, and write an XML stylesheet; be able to use Cypher to query a graph database have a sound understanding of database architectures and their managerial implications; be familiar with the full range of technologies available for organizational memory; be able to write a Java program to create a table from a CSV file and process a transaction; understand the fundamentals of data administration; My goal is to give you a data management text that is innovative, relevant, and lively. I trust that you will enjoy learning about managing data in today’s organization. Supplements Accompanying this book are an instructor’s manual and an extensive Web site that provides - slides in PowerPoint format; - all relational tables in the book in electronic format; - code for examples in the book; - answers to many of the exercises; - additional exercises. Acknowledgments I thank my wife, Clare, and son, Ned, for help with prior editions of the book. I appreciate the efforts of Christopher Gauthier in converting the prior edition to Bookdown format. Richard T. Watson Athens, Georgia "],["section-1-introduction-to-sql.html", "Section 1 Introduction to SQL", " Section 1 Introduction to SQL It is a capital mistake to theorize before one has data. Sir Arthur Conan Doyle, “A Scandal in Bohemia,” The Adventures of Sherlock Holmes, 1891 The application backlog, a large number of requests for new information systems, has been a recurring problem in many organizations for decades. The demand for new information systems and the need to maintain existing systems have usually outstripped available information systems skills. The application backlog, unfortunately, is not a new problem. In the 1970s, Codd laid out a plan for improving programmer productivity and accelerating systems development by improving the management of data. Codd’s relational model, designed to solve many of the shortcomings of earlier systems, has long been the most popular database model. This section develops two key skills—data modeling and query formation—that are required to take advantage of the relational model. You will concentrate on the design and use of relational databases. This very abrupt change in focus is part of the plan to give you a dual understanding of data management. Section 1 is the managerial perspective, whereas this section covers technical skills development. Competent data managers are able to accommodate both views and apply whichever (or some blend of the two) is appropriate. In Chapter 1, many forms of organizational memory were identified, and in this section we focus on files and their components. Thus, only the files branch of organizational memory is detailed in the following figure. A collection of related files is a database. Describing the collection of files as related means that it has a common purpose (e.g., data about students). Sometimes files are also called tables, and there are synonyms for some other terms (the alternative names are shown in parentheses). Files contain records (or rows). Each record contains the data for one instance of an observation. For example, if the file stores data about students, each record will contain data about a single student. Records have fields (or columns) that store the fine detail of each instance (e.g., student’s first name, last name, and date of birth). Fields are composed of characters (a, b, c,.., 1, 2, 3,…, %, $, #,…, A, B, etc.). A byte, a unit of storage sufficient to store a single letter (in English), consists of a string of eight contiguous bits or binary digits. The data management hierarchy stimulates three database design questions: What collection of files should the database contain? How are these files related? What fields should each record in the file contain? The first objective of this section is to describe data modeling, a technique for answering the three questions. Data modeling helps you to understand the structure and meaning of data, which is necessary before a database can be created. Once a database has been designed, built, and loaded with data, the aim is to deploy it to satisfy management’s requests for information. Thus, the second objective is to teach you to query a relational database. The learning of modeling and querying will be intertwined, making it easier to grasp the intent of database design and to understand why data modeling is so critical to making a database an effective tool for managerial decision making. Chapter 3 covers modeling a single entity and querying a single-table database. This is the simplest database that can be created. As you will soon discover, a data model is a graphical description of the components of a database. One of these components is an entity, some feature of the real world about which data must be stored. This section also introduces the notions of a data definition language (DDL), which is used to describe a database, and a data manipulation language (DML), which is used to maintain and query a database. Subsequent chapters in this section cover advanced data modeling concepts and querying capabilities. "],["the-single-entity.html", "Chapter 1 The Single Entity The relational model Getting started Modeling a single-entity database Creating a single-table database Querying a single-table database Exercises", " Chapter 1 The Single Entity I want to be alone. Attributed to Greta Garbo Learning Objectives Students completing this chapter will be able to model a single entity; define a single database; write queries for a single-table database. The relational model The relational model introduced by Codd in 1970 is the most popular technology for managing large collections of data. In this chapter, the major concepts of the relational model are introduced. Extensive coverage of the relational model is left until Chapter 8, by which time you will have sufficient practical experience to appreciate fully its usefulness, value, and elegance. A relation, similar to the mathematical concept of a set, is a two-dimensional table arranged in rows and columns. This is a very familiar idea. You have been using tables for many years. A relational database is a collection of relations, where relation is a mathematical term for a table. One row of a table stores details of one observation, instance, or case of an item about which facts are retained—for example, one row for details of a particular student. All the rows in a table store data about the same type of item. Thus, a database might have one table for student data and another table for class data. Similarly, each column in the table contains the same type of data. For example, the first column might record a student’s identification number. A key database design question is to decide what to store in each table. What should the rows and columns contain? In a relational database, each row must be uniquely identified. There must be a primary key, such as student identifier, so that a particular row can be designated. The use of unique identifiers is very common. Telephone numbers and e-mail addresses are examples of unique identifiers. Selection of the primary key, or unique identifier, is another key issue of database design. 💠 Global legal entity identifier (LEI) There is no global standard for identifying legal entities across markets and jurisdictions. The need for such a standard was amplified by Lehman Brothers collapse in 2008. Lehman had 209 registered subsidiaries, legal entities, in 21 countries, and it was party to more than 900,000 derivatives contracts upon its collapse. Key stakeholders, such as financial regulators and Lehman’s creditors, were unable to assess their exposure. Furthermore, others were unable to assess the possible ripple on them of the effects of the collapse because of the transitive nature of many investments (i.e., A owes B, B owes C, and C owes D). The adoption of a global legal entity identifier (LEI), should improve financial system regulation and corporate risk management. Regulators will find it easier to monitor and analyze threats to financial stability and risk managers will be more able evaluate their companies’ risks. The tables in a relational database are connected or related by means of the data in the tables. You will learn, in the next chapter, that this connection is through a pair of values—a primary key and a foreign key. Consider a table of airlines serving a city. When examining this table, you may not recognize the code of an airline, so you then go to another table to find the name of the airline. For example, if you inspect the next table, you find that AM is an international airline serving Atlanta. International airlines serving Atlanta Airline AM JL KX LM MA OS RG SN SR LH LY If you don’t know which airline has the abbreviation AM, then you need to look at the table of airline codes to discover that AeroMexico, with code AM, serves Atlanta. The two tables are related by airline code. Later, you will discover which is the primary key and which is the foreign key. A partial list of airline codes Code Airline AA American Airlines AC Air Canada AD Lone Star Airlines AE Mandarin Airlines AF Air France AG Interprovincial Airlines AI Air India AM AeroMexico AQ Aloha Airlines When designing the relational model, Codd provided commands for processing multiple records at a time. His intention was to increase the productivity of programmers by moving beyond the record-at-a-time processing that is found in most programming languages. Consequently, the relational model supports set processing (multiple records-at-a-time), which is most frequently implemented as Structured Query Language (SQL).1 The relational model separates the logical design of a database from its physical storage. This notion of data independence simplifies data modeling and database programming. In this section, we focus on logical database design, and now that you have had a brief introduction to the relational model, you are ready to learn data modeling. Getting started As with most construction projects, building a relational database must be preceded by a design phase. Data modeling, our design technique, is a method for creating a plan or blueprint of a database. The data model must accurately mirror real-world relationships if it is to support processing business transactions and managerial decision making. Rather than getting bogged down with a theory first, application later approach to database design and use, we will start with application. We will get back to theory when you have some experience in data modeling and database querying. After all, you did not learn to talk by first studying sentence formation; you just started by learning and using simple words. We start with the simplest data model, a single entity, and the simplest database, a single table, as follows. Share code Share name Share price Share quantity Share dividend PE ratio FC Freedonia Copper 27.5 10,529 1.84 16 PT Patagonian Tea 55.25 12,635 2.50 10 AR Abyssinian Ruby 31.82 22,010 1.32 13 SLG Sri Lankan Gold 50.37 32,868 2.68 16 ILZ Indian Lead &amp; Zinc 37.75 6,390 3.00 12 BE Burmese Elephant 0.07 154,713 0.01 3 BS Bolivian Sheep 12.75 231,678 1.78 11 NG Nigerian Geese 35.00 12,323 1.68 10 CS Canadian Sugar 52.78 4,716 2.50 15 ROF Royal Ostrich Farms 33.75 1,234,923 3.00 6 Modeling a single-entity database The simplest database contains information about one entity, which is some real-world thing. Some entities are physical—CUSTOMER, ORDER, and STUDENT; others are abstract or conceptual—WORK ASSIGNMENT, and AUTHORSHIP. We represent an entity by a rectangle: the following figure shows a representation of the entity SHARE. The name of the entity is shown in singular form in uppercase in the top part of the rectangle. The entity SHARE An entity has characteristics or attributes. An attribute is a discrete element of data; it is not usually broken down into smaller components. Attributes are describe the data we want to store. Some attributes of the entity SHARE are share code, share name, share price, share quantity (number owned), share dividend, and PE ratio (price-to-earnings ratio).2 Attributes are shown below the entity’s name. Notice that we refer to share price, rather than price, to avoid confusion if there should be another entity with an attribute called price. Attribute names must be carefully selected so that they are self-explanatory and unique. For example, share dividend is easily recognized as belonging to the entity SHARE. The entity SHARE and its attributes An instance is a particular occurrence of an entity (e.g., facts about Freedonia Copper). To avoid confusion, each instance of an entity needs to be uniquely identified. Consider the case of customer billing. In most cases, a request to bill Smith $100 cannot be accurately processed because a firm might have more than one Smith in its customer file. If a firm has carefully controlled procedures for ensuring that each customer has a unique means of identification, then a request to bill customer number 1789 $100 can be accurately processed. An attribute or collection of attributes that uniquely identifies an instance of an entity is called an identifier. The identifier for the entity SHARE is share code, a unique identifier assigned by the stock exchange to a firm issuing shares. There may be several attributes, or combinations of attributes, that are feasible identifiers for an instance of an entity. Attributes that are identifiers are prefixed by an asterisk. The following figure shows an example of a representation of an entity, its attributes, and identifier. The entity SHARE, its attributes, and identifier Briefly, entities are things in the environment about which we wish to store information. Attributes describe an entity. An entity must have a unique identifier. The modeling language used in this text is designed to record the essential details of a data model. The number of modeling symbols to learn is small, and they preserve all the fundamental concepts of data modeling. Since data modeling often occurs in a variety of settings, the symbols used have been selected so that they can be quickly drawn using pencil-and-paper, whiteboard, or a general-purpose drawing program. This also means that models can be quickly revised as parts can be readily erased and redrawn. The symbols are distinct and visual clutter is minimized because only the essential information is recorded. This also makes the language easy for clients to learn so they can read and amend models. Models can be rapidly translated to a set of tables for a relational database. More importantly, since this text implements the fundamental notions of all data modeling languages, you can quickly convert to another data modeling dialect. Data modeling is a high-level skill, and the emphasis needs to be on learning to think like a data modeler rather than on learning a modeling language. This text’s goal is to get you off to a fast start. ❓ Skill builder A ship has a name, registration code, gross tonnage, and a year of &gt;construction. Ships are classified as cargo or passenger. Draw a data model &gt;for a ship. Creating a single-table database The next stage is to translate the data model into a relational database. The translation rules are very direct: Each entity becomes a table. The entity name becomes the table name. Each attribute becomes a column. The identifier becomes the primary key. The American National Standards Institute’s (ANSI) recommended language for relational database definition and manipulation is SQL, which is both a data definition language (DDL) (to define a database), a data manipulation language (DML) (to query and maintain a database), and a data control language (DCL) (to control access). SQL is a common standard for describing and querying databases and is available with many commercial relational database products, including DB2, Oracle, and Microsoft SQL Server, and open source products such as MySQL and PostgreSQL. In this book, MySQL is the relational database for teaching SQL. Because SQL is a standard, it does not matter which implementation of the relational model you use as the SQL language is common across both the proprietary and open variants.3 SQL uses the CREATE4 statement to define a table. It is not a particularly friendly command, and most products have friendlier interfaces for defining tables. However, it is important to learn the standard, because this is the command that SQL understands. Also, a table definition interface will generate a CREATE statement for execution by SQL. Your interface interactions ultimately translate into a standard SQL command. It is common practice to abbreviate attribute names, as is done in the following example. Defining a table The CREATE command to establish a table called share is as follows: CREATE TABLE share ( shrcode CHAR(3), shrfirm VARCHAR(20) NOT NULL, shrprice DECIMAL(6,2), shrqty DECIMAL(8), shrdiv DECIMAL(5,2), shrpe DECIMAL(2), PRIMARY KEY (shrcode)); The first line of the command names the table; subsequent lines describe each of its columns. The first component is the name of the column (e.g., shrcode). The second component is the data type (e.g., CHAR), and its length is shown in parentheses. shrfirm is a variable-length character field of length 20, which means it can store up to 20 characters, including spaces. The column shrdiv stores a decimal number that can be as large as 999.99 because its total length is 5 digits and there are 2 digits to the right of the decimal point. Some examples of allowable data types are shown in the following table. The third component (e.g., NOT NULL), which is optional, indicates any instance that cannot have null values. A column might have a null value when it is either unknown or not applicable. In the case of the share table, we specify that shrfirm must be defined for each instance in the database. The final line of the CREATE statement defines shrcode as the primary key, the unique identifier for SHARE When a primary key is defined, the relational database management system (RDBMS) will enforce the requirement that the primary key is unique and not null. Before any row is added to the table SHARE, the RDBMS will check that the value of shrcode is not null and that there does not already exist a duplicate value for shrcode in an existing row of share. If either of these constraints is violated, the RDBMS will not permit the new row to be inserted. This constraint, the entity integrity rule, ensures that every row has a unique, non-null primary key. Allowing the primary key to take a null value would mean there could be a row of share that is not uniquely identified. Note that an SQL statement is terminated by a semicolon, though this is not always enforced. SQL statements can be written in any mix of valid upper and lowercase characters. To make it easier for you to learn the syntax, this book adopts the following conventions: SQL keywords are in uppercase. Table and column names are in lowercase. There are more elaborate layout styles, but we will bypass those because it is more important at this stage to learn SQL. You should lay out your SQL statements so that they are easily read by you and others. The following table shows some of the data types supported by most relational databases. Other implementations of the relational model may support some of these data types and additional ones. It is a good idea to review the available data types in your RDBMS before defining your first table. Some allowable data types Category Data type Description Numeric SMALLINT A 15-bit signed binary value INTEGER A 31-bit signed binary value FLOAT(p) A scientific format number of p binary digits precision DECIMAL(p,q) A packed decimal number of p digits total length; q decimal spaces to the right of the decimal point may be specified String CHAR(n) A fixed-length string of n characters VARCHAR(n) A variable-length string of up to n characters text A variable-length string of up to 65,535 characters Date/time DATE Date in the form yyyymmdd TIME Time in the form hhmmss timesTAMP A combination of date and time to the nearest microsecond time with time zone Same as time, with the addition of an offset from universal time coordinated (UTC) of the specified time timestamp with time zone Same as timestamp, with the addition of an offset from UTC of the specified time Logical Boolean A set of truth values: TRUE, FALSE, or UNKNOWN The CHAR and VARCHAR data types are similar but differ in the way character strings are stored and retrieved. Both can be up to 255 characters long. The length of a CHAR column is fixed to the declared length. When values are stored, they are right-padded with spaces to the specified length. When CHAR values are retrieved, trailing spaces are removed. VARCHAR columns store variable-length strings and use only as many characters as are needed to store the string. Values are not padded; instead, trailing spaces are removed. In this book, we use VARCHAR to define most character strings, unless they are short (less than five characters is a good rule-of-thumb). Data modeling with MySQL Workbench MySQL Workbench is a professional quality, open source, cross-platform tool for data modeling and SQL querying. In this text, you will also learn some of the features of Workbench that support data modeling and using SQL. You will find it helpful to complete the tutorial on creating a data model prior to further reading, as we will assume you have such proficiency. The entity share created with MySQL Workbench You will notice some differences from the data model we have created previously. Workbench automatically generates the SQL code to create the table, so when modeling you establish the names you want for tables and columns. A gold key symbol is used to indicate the identifier, which becomes the primary key. An open diamond indicates that a column can be null, whereas a closed blue diamond indicate the column must have a value, as with shrfirm in this case. When specifying columns in Workbench you must also indicate the datatype. We opt to turn off the display of a column’s datatype5 in a model to maintain focus on the entity. A major advantage of using a tool such as Workbench is that it will automatically generate the CREATE statement code (Database &gt; Forward Engineer …) and execute the code to create the database. The Workbench tutorial will have shown you how to do this, and you should try this out for yourself by creating a database with the single share table. Inserting rows into a table The rows of a table store instances of an entity. A particular shareholding (e.g., Freedonia Copper) is an example of an instance of the entity share. The SQL statement INSERT is used to add rows to a table. Although most implementations of the relational model use an application for row insertion, if authorized, you might also use a RDBMS interface spreadsheet or import a structured text file, such as Comma Separated Value (CSV) file. The INSERT command is defined for completeness. The following command adds one row to the table share: INSERT INTO share (shrcode,shrfirm,shrprice,shrqty,shrdiv,shrpe) VALUES (&#39;FC&#39;,&#39;Freedonia Copper&#39;,27.5,10529,1.84,16); There is a one-to-one correspondence between a column name in the first set of parentheses and a value in the second set of parentheses. That is, shrcode has the value “FC”, shrfirm the value “Freedonia Copper”, and so on. Notice that the value of a column that stores a character string (e.g., shrfirm) is contained within straight quotes. The list of field names can be omitted when values are inserted in all columns of the table in the same order as that specified in the CREATE statement, so the preceding expression could be written INSERT INTO share VALUES (&#39;FC&#39;,&#39;Freedonia Copper&#39;,27.5,10529,1.84,16); The data for the share table will be used in subsequent examples. If you have ready access to a relational database, it is a good idea to now create a table and enter the data. Then you will be able to use these data to practice querying the table. Data for share *Code Name Price Quantity Dividend PE FC Freedonia Copper 27.5 10,529 1.84 16 PT Patagonian Tea 55.25 12,635 2.50 10 AR Abyssinian Ruby 31.82 22,010 1.32 13 SLG Sri Lankan Gold 50.37 32,868 2.68 16 ILZ Indian Lead &amp; Zinc 37.75 6,390 3.00 12 BE Burmese Elephant 0.07 154,713 0.01 3 BS Bolivian Sheep 12.75 231,678 1.78 11 NG Nigerian Geese 35.00 12,323 1.68 10 CS Canadian Sugar 52.78 4,716 2.50 15 ROF Royal Ostrich Farms 33.75 1,234,923 3.00 6 Notice that shrcode,the primary key, is asterisked in the preceding table. This is a convention we will use, as in data modeling, to denote the primary key. In the relational model, an identifier becomes a primary key, a column that guarantees that each row of the table can be uniquely addressed. MySQL Workbench offers a spreadsheet interface for entering data, as explained in the tutorial. Inserting rows with MySQL Workbench ❓ Skill builder Create a relational database for the ship entity you modeled previously. &gt;Insert some rows. Querying a single-table database The objective of developing a database is to make it easier to use the stored data to solve problems. Typically, a manager raises a question (e.g., How many shares have a PE ratio greater than 12?). A question or request for information, usually called a query, is then translated into a specific data manipulation or query language. The most widely used query language for relational databases is SQL. After the query has been executed, the resulting data are displayed. In the case of a relational database, the answer to a query is always a table. There is also a query language called relational algebra, which describes a set of operations on tables. Sometimes it is useful to think of queries in terms of these operations. Where appropriate, we will introduce the corresponding relational algebra operation. Generally we use a four-phase format for describing queries: A brief explanation of the query’s purpose The query in italics, prefixed by •, and some phrasing you might expect from a manager The SQL version of the query The results of the query. Displaying an entire table All the data in a table can be displayed using the SELECT statement. In SQL, the all part is indicated by an asterisk (*). List all data in the share table. SELECT * FROM share; Table 1.1: Displaying records 1 - 10 shrcode shrfirm shrprice shrqty shrdiv shrpe AR Abyssinian Ruby 31.82 22010 1.32 13 BE Burmese Elephant 0.07 154713 0.01 3 BS Bolivian Sheep 12.75 231678 1.78 11 CS Canadian Sugar 52.78 4716 2.50 15 FC Freedonia Copper 27.50 10529 1.84 16 ILZ Indian Lead &amp; Zinc 37.75 6390 3.00 12 NG Nigerian Geese 35.00 12323 1.68 10 PT Patagonian Tea 55.25 12635 2.50 10 ROF Royal Ostrich Farms 33.75 1234923 3.00 6 SLG Sri Lankan Gold 50.37 32868 2.68 16 Project—choosing columns The relational algebra operation project creates a new table from the columns of an existing table. Project takes a vertical slice through a table by selecting all the values in specified columns. The projection of share on columns shrfirm and shrpe produces a new table with 10 rows and 2 columns. The SQL syntax for the project operation simply lists the columns to be displayed. Report a firm’s name and price-earnings ratio. SELECT shrfirm, shrpe FROM share; Table 1.2: Displaying records 1 - 10 shrfirm shrpe Abyssinian Ruby 13 Burmese Elephant 3 Bolivian Sheep 11 Canadian Sugar 15 Freedonia Copper 16 Indian Lead &amp; Zinc 12 Nigerian Geese 10 Patagonian Tea 10 Royal Ostrich Farms 6 Sri Lankan Gold 16 Restrict—choosing rows The relational algebra operation restrict creates a new table from the rows of an existing table. The operation restricts the new table to those rows that satisfy a specified condition. Restrict takes all columns of an existing table but only those rows that meet the specified condition. The restriction of share to those rows where the PE ratio is less than 12 will give a new table with five rows and six columns. Restrict is implemented in SQL using the WHERE clause to specify the condition on which rows are restricted. Get all firms with a price-earnings ratio less than 12. SELECT * FROM share WHERE shrpe &lt; 12; Table 1.3: 5 records shrcode shrfirm shrprice shrqty shrdiv shrpe BE Burmese Elephant 0.07 154713 0.01 3 BS Bolivian Sheep 12.75 231678 1.78 11 NG Nigerian Geese 35.00 12323 1.68 10 PT Patagonian Tea 55.25 12635 2.50 10 ROF Royal Ostrich Farms 33.75 1234923 3.00 6 In this example, we have a less than condition for the WHERE clause. All permissible comparison operators are listed below. Operator Meaning = Equal to &lt; Less than &lt;= Less than orequal to &gt; Greater than &gt;= Greater than or equal to &lt;&gt; Not equal to In addition to the comparison operators, the BETWEEN construct is available. The expression a BETWEEN x AND y is equivalent to a &gt;= x AND a &lt;= y. Combining project and restrict—choosing rows and columns SQL permits project and restrict to be combined. A single SQL SELECT statement can specify which columns to project and which rows to restrict. List the name, price, quantity, and dividend of each firm where the share holding is at least 100,000. SELECT shrfirm, shrprice, shrqty, shrdiv FROM share WHERE shrqty &gt;= 100000; Table 1.4: 3 records shrfirm shrprice shrqty shrdiv Burmese Elephant 0.07 154713 0.01 Bolivian Sheep 12.75 231678 1.78 Royal Ostrich Farms 33.75 1234923 3.00 More about WHERE The WHERE clause can contain several conditions linked by AND or OR. A clause containing AND means all specified conditions must be true for a row to be selected. In the case of OR, at least one of the conditions must be true for a row to be selected. Find all firms where the PE is 12 or higher and the share holding is less than 10,000. SELECT * FROM share WHERE shrpe &gt;= 12 AND shrqty &lt; 10000; Table 1.5: 2 records shrcode shrfirm shrprice shrqty shrdiv shrpe CS Canadian Sugar 52.78 4716 2.5 15 ILZ Indian Lead &amp; Zinc 37.75 6390 3.0 12 The power of the primary key The purpose the primary key is to guarantee that any row in a table can be uniquely addressed. In this example, we use shrcode to return a single row because shrcode is unique for each instance of share. The sought code (AR) must be specified in quotes because shrcode was defined as a character string when the table was created. Report firms whose code is AR. SELECT * FROM share WHERE shrcode = &#39;AR&#39;; Table 1.6: 1 records shrcode shrfirm shrprice shrqty shrdiv shrpe AR Abyssinian Ruby 31.82 22010 1.32 13 A query based on a non-primary-key column cannot guarantee that a single row is accessed, as the following illustrates. Report firms with a dividend of 2.50. SELECT * FROM share WHERE shrdiv = 2.5; Table 1.7: 2 records shrcode shrfirm shrprice shrqty shrdiv shrpe CS Canadian Sugar 52.78 4716 2.5 15 PT Patagonian Tea 55.25 12635 2.5 10 The IN crowd The keyword IN is used with a list to specify a set of values. IN is always paired with a column name. All rows for which a value in the specified column has a match in the list are selected. It is a simpler way of writing a series of OR statements. Report data on firms with codes of FC, AR, or SLG. SELECT * FROM share WHERE shrcode IN (&#39;FC&#39;,&#39;AR&#39;,&#39;SLG&#39;); The foregoing query could have also been written as SELECT * FROM share WHERE shrcode = &#39;FC&#39; or shrcode = &#39;AR&#39; or shrcode = &#39;SLG&#39;; Table 1.8: 3 records shrcode shrfirm shrprice shrqty shrdiv shrpe AR Abyssinian Ruby 31.82 22010 1.32 13 FC Freedonia Copper 27.50 10529 1.84 16 SLG Sri Lankan Gold 50.37 32868 2.68 16 The NOT IN crowd A NOT IN list is used to report instances that do not match any of the values. Report all firms other than those with the code CS or PT. SELECT * FROM share WHERE shrcode NOT IN (&#39;CS&#39;,&#39;PT&#39;); is equivalent to SELECT * FROM share WHERE shrcode &lt;&gt; &#39;CS&#39; AND shrcode &lt;&gt; &#39;PT&#39;; Table 1.9: 8 records shrcode shrfirm shrprice shrqty shrdiv shrpe AR Abyssinian Ruby 31.82 22010 1.32 13 BE Burmese Elephant 0.07 154713 0.01 3 BS Bolivian Sheep 12.75 231678 1.78 11 FC Freedonia Copper 27.50 10529 1.84 16 ILZ Indian Lead &amp; Zinc 37.75 6390 3.00 12 NG Nigerian Geese 35.00 12323 1.68 10 ROF Royal Ostrich Farms 33.75 1234923 3.00 6 SLG Sri Lankan Gold 50.37 32868 2.68 16 ❓ Skill Builder List those shares where the value of the holding exceeds one million. Ordering columns The order of reporting columns is identical to their order in the SQL command. For instance, compare the output of the following queries. SELECT shrcode, shrfirm FROM share WHERE shrpe = 10; Table 1.10: 2 records shrcode shrfirm NG Nigerian Geese PT Patagonian Tea SELECT shrfirm, shrcode FROM share WHERE shrpe = 10; Table 1.11: 2 records shrfirm shrcode Nigerian Geese NG Patagonian Tea PT Ordering rows People can generally process an ordered (e.g., sorted alphabetically) report faster than an unordered one. In SQL, the ORDER BY clause specifies the row order in a report. The default ordering sequence is ascending (A before B, 1 before 2). Descending is specified by adding DESC after the column name. List all firms where PE is at least 10, and order the report in descending PE. Where PE ratios are identical, list firms in alphabetical order. SELECT * FROM share WHERE shrpe &gt;= 10 ORDER BY shrpe DESC, shrfirm; Table 1.12: 8 records shrcode shrfirm shrprice shrqty shrdiv shrpe FC Freedonia Copper 27.50 10529 1.84 16 SLG Sri Lankan Gold 50.37 32868 2.68 16 CS Canadian Sugar 52.78 4716 2.50 15 AR Abyssinian Ruby 31.82 22010 1.32 13 ILZ Indian Lead &amp; Zinc 37.75 6390 3.00 12 BS Bolivian Sheep 12.75 231678 1.78 11 NG Nigerian Geese 35.00 12323 1.68 10 PT Patagonian Tea 55.25 12635 2.50 10 Numeric versus character sorting Numeric data in character fields (e.g., a product code) do not always sort the way you initially expect. The difference arises from the way data are stored: Numeric fields are right justified and have leading zeros. Character fields are left justified and have trailing spaces. For example, the value 1066 stored as CHAR(4) would be stored as ‘1066’ and the value 45 would be stored as ‘45’. If the column containing these data is sorted in ascending order, then ‘1066’ precedes ‘45’ because the leftmost character ‘1’ is less than ‘4’. You can avoid this problem by always storing numeric values as numeric data types (e.g., integer or decimal) or preceding numeric values with zeros when they are stored as character data. Alternatively, start numbering at 1,000 so that all values are four digits, though the best solution is to store numeric data as numbers rather than characters. Derived data One of the important principles of database design is to avoid redundancy. One form of redundancy is including a column in a table when these data can be derived from other columns. For example, we do not need a column for yield because it can be calculated by dividing dividend by price and multiplying by 100 to obtain the yield as a percentage. This means that the query language does the calculation when the value is required. Get firm name, price, quantity, and firm yield. SELECT shrfirm, shrprice, shrqty, shrdiv/shrprice*100 AS yield FROM share; Table 1.13: Displaying records 1 - 10 shrfirm shrprice shrqty yield Abyssinian Ruby 31.82 22010 4.148334 Burmese Elephant 0.07 154713 14.285714 Bolivian Sheep 12.75 231678 13.960784 Canadian Sugar 52.78 4716 4.736643 Freedonia Copper 27.50 10529 6.690909 Indian Lead &amp; Zinc 37.75 6390 7.947020 Nigerian Geese 35.00 12323 4.800000 Patagonian Tea 55.25 12635 4.524887 Royal Ostrich Farms 33.75 1234923 8.888889 Sri Lankan Gold 50.37 32868 5.320627 You can give the results of the calculation a column name. In this case, a good choice is yield. Note the use of AS to indicate the name of the column in which the results of the calculation are displayed. In the preceding query, the keyword AS is introduced to specify an alias, or temporary name. The statement specifies that the result of the calculation is to be reported under the column heading yield. You can rename any column or specify a name for the results of an expression using an alias. Aggregate functions SQL has built-in functions to enhance its retrieval power and handle many common aggregation queries, such as computing the total value of a column. Four of these functions (AVG, SUM, MIN, and MAX) work very similarly. COUNT is a little different. COUNT COUNT computes the number of rows in a table. Use COUNT(*) to count all rows irrespective of their content (i.e., null or not null), and use COUNT(columnname) to count rows without a null value for columname. Count can be used with a WHERE clause to specify a condition. How many firms are there in the portfolio? SELECT COUNT(shrcode) AS investments FROM share; Table 1.14: 1 records investments 10 How many firms have a holding greater than 50,000? SELECT COUNT(shrfirm) AS bigholdings FROM share WHERE shrqty &gt; 50000; Table 1.15: 1 records bigholdings 3 AVG—averaging AVG computes the average of the values in a column of numeric data. Null values in the column are not included in the calculation. Find the average dividend. SELECT AVG(shrdiv) AS avgdiv FROM share; Table 1.16: 1 records avgdiv 2.031 What is the average yield for the portfolio? SELECT AVG(shrdiv/shrprice*100) AS avgyield FROM share; Table 1.17: 1 records avgyield 7.530381 SUM, MIN, and MAX SUM, MIN, and MAX differ in the statistic they calculate but are used similarly to AVG. As with AVG, null values in a column are not included in the calculation. SUM computes the sum of a column of values. MIN finds the smallest value in a column; MAX finds the largest. Subqueries Sometimes we need the answer to another query before we can write the query of ultimate interest. For example, to list all shares with a PE ratio greater than the portfolio average, you first must find the average PE ratio for the portfolio. You could do the query in two stages: SELECT AVG(shrpe) FROM share; and SELECT shrfirm, shrpe FROM share WHERE shrpe &gt; x; where x is the value returned from the first query. Unfortunately, the two-stage method introduces the possibility of errors. You might forget the value returned by the first query or enter it incorrectly. It also takes longer to get the results of the query. We can solve these problems by using parentheses to indicate the first query is nested within the second one. As a result, the value returned by the inner or nested subquery, the one in parentheses, is used in the outer query. In the following example, the nested query returns 11.20, which is then automatically substituted in the outer query. Report all firms with a PE ratio greater than the average for the portfolio. SELECT shrfirm, shrpe FROM share WHERE shrpe &gt; (SELECT AVG(shrpe) FROM share); Table 1.18: 5 records shrfirm shrpe Abyssinian Ruby 13 Canadian Sugar 15 Freedonia Copper 16 Indian Lead &amp; Zinc 12 Sri Lankan Gold 16 ⚠️ The preceding query is often mistakenly written as SELECT shrfirm, shrpe from share WHERE shrpe &gt; avg(shrpe); You need to use a subquery to find the average, so the computed value can be used in the outer query ❓ Skill builder Find the name of the firm for which the value of the holding is greatest. Regular expression—pattern matching Regular expression is a concise and powerful method for searching for a specified pattern in a nominated column. Regular expression processing is supported by languages such as Java, R, and PHP. In this chapter, we introduce a few typical regular expressions and will continue developing your knowledge of this feature in the next chapter. Search for a string List all firms containing ‘Ruby’ in their name. SELECT shrfirm FROM share WHERE shrfirm REGEXP &#39;Ruby&#39;; Table 1.19: 1 records shrfirm Abyssinian Ruby Search for alternative strings In some situations you want to find columns that contain more than one string. In this case, we use the alternation symbol ‘|’ to indicate the alternatives being sought. For example, a|b finds ‘a’ or ‘b’. List firms containing gold or zinc in their name, irrespective of case. SELECT shrfirm FROM share WHERE shrfirm REGEXP &#39;gold|zinc|Gold|Zinc&#39;; Table 1.20: 2 records shrfirm Indian Lead &amp; Zinc Sri Lankan Gold Search for a beginning string If you are interested in finding a value in a column that starts with a particular character string, then use ^ to indicate this option. List the firms whose name begins with Sri. SELECT shrfirm FROM share WHERE shrfirm REGEXP &#39;^Sri&#39;; Table 1.21: 1 records shrfirm Sri Lankan Gold Search for an ending string If you are interested in finding if a value in a column ends with a particular character string, then use $ to indicate this option. List the firms whose name ends with Geese. SELECT shrfirm FROM share WHERE shrfirm REGEXP &#39;Geese$&#39;; Table 1.22: 1 records shrfirm Nigerian Geese ❓ Skill builder List the firms containing “ian” in their name. DISTINCT—eliminating duplicate rows The DISTINCT clause is used to eliminate duplicate rows. It can be used with column functions or before a column name. When used with a column function, it ignores duplicate values. Report the different values of the PE ratio. SELECT DISTINCT shrpe FROM share; Table 1.23: 8 records shrpe 13 3 11 15 16 12 10 6 Find the number of different PE ratios. SELECT COUNT(DISTINCT shrpe) as &#39;Different PEs&#39; FROM share; Table 1.24: 1 records Different PEs 8 When used before a column name, DISTINCT prevents the selection of duplicate rows. Notice a slightly different use of the keyword AS. In this case, because the alias includes a space, the entire alias is enclosed in straight quotes. DELETE Rows in a table can be deleted using the DELETE clause in an SQL statement. DELETE is typically used with a WHERE clause to specify the rows to be deleted. If there is no WHERE clause, all rows are deleted. Erase the data for Burmese Elephant. All the shares have been sold. DELETE FROM share WHERE shrfirm = &#39;Burmese Elephant&#39;; In the preceding statement, shrfirm is used to indicate the row to be deleted. UPDATE Rows can be modified using SQL’s UPDATE clause, which is used with a WHERE clause to specify the rows to be updated. Change the share price of FC to 31.50. UPDATE share SET shrprice = 31.50 WHERE shrcode = &#39;FC&#39;; Increase the total number of shares for Nigerian Geese by 10% because of the recent bonus issue. UPDATE share SET shrqty = shrqty*1.1 WHERE shrfirm = &#39;Nigerian Geese&#39;; Quotes There are three types of quotes that you can typically use with SQL. Double and single quotes are equivalent and can be used interchangeably. Note that single and double quotes must be straight rather than curly, and the back quote is to the left of the 1 key. Type of quote Representation Single ’ Double “ Back ` The following SQL illustrates the use of three types of quotes to find a person with a last name of O’Hara and where the column names are person first and person last. SELECT `person first` FROM person WHERE `person last` = &quot;O&#39;Hara&quot;; Table 1.25: 1 records person first Sheila Debriefing Now that you have learned how to model a single entity, create a table, and specify queries, you are on the way to mastering the fundamental skills of database design, implementation, and use. Remember, planning occurs before action. A data model is a plan for a database. The action side of a database is inserting rows and running queries. Summary The relational database model is an effective means of representing real-world relationships. Data modeling is used to determine what data must be stored and how data are related. An entity is something in the environment. An entity has attributes, which describe it, and an identifier, which uniquely distinguishes an instance of an entity. Every entity must have a unique identifier. A relational database consists of tables with rows and columns. A data model is readily translated into a relational database. The SQL statement CREATE is used to define a table. Rows are added to a table using INSERT. In SQL, queries are written using the SELECT statement. Project (choosing columns) and restrict (choosing rows) are common table operations. The WHERE clause is used to specify row selection criteria. WHERE can be combined with IN and NOT IN, which specify values for a single column. The rows of a report are sorted using the ORDER BY clause. Arithmetic expressions can appear in SQL statements, and SQL has built-in functions for common arithmetic operations. A subquery is a query within a query. Regular expressions are used to find string patterns within character strings. Duplicate rows are eliminated with the DISTINCT clause. Rows can be erased using DELETE or modified with UPDATE. Key terms and concepts Alias Instance AS MAX Attribute MIN AVG NOT IN Column ORDER BY COUNT Primary key CREATE Project Data modeling Relational database Data type Restrict Database Row DELETE SELECT DISTINCT SQL Entity Subquery Entity integrity rule SUM Identifier Table IN UPDATE INSERT WHERE Exercises Draw data models for the following entities. In each case, make certain that you show the attributes and identifiers. Also, create a relational database and insert some rows for each of the models. Aircraft: An aircraft has a manufacturer, model number, call sign (e.g., N123D), payload, and a year of construction. Aircraft are classified as civilian or military. Car: A car has a manufacturer, range name, and style code (e.g., a Honda Accord DX, where Honda is the manufacturer, Accord is the range, and DX is the style). A car also has a vehicle identification code, registration code, and color. Restaurant: A restaurant has an address, seating capacity, phone number, and style of food (e.g., French, Russian, Chinese). Cow: A dairy cow has a name, date of birth, breed (e.g., Holstein), and a numbered plastic ear tag. Do the following queries using SQL: List a share’s name and its code. List full details for all shares with a price less than $1. List the names and prices of all shares with a price of at least $10. Create a report showing firm name, share price, share holding, and total value of shares held. (Value of shares held is price times quantity.) List the names of all shares with a yield exceeding 5 percent. Report the total dividend payment of Patagonian Tea. (The total dividend payment is dividend times quantity.) Find all shares where the price is less than 20 times the dividend. Find the share(s) with the minimum yield. Find the total value of all shares with a PE ratio &gt; 10. Find the share(s) with the maximum total dividend payment. Find the value of the holdings in Abyssinian Ruby and Sri Lankan Gold. Find the yield of all firms except Bolivian Sheep and Canadian Sugar. Find the total value of the portfolio. List firm name and value in descending order of value. List shares with a firm name containing “Gold.” Find shares with a code starting with “B.” Run the following queries and explain the differences in output. Write each query as a manager might state it. SELECT shrfirm FROM share WHERE shrfirm NOT REGEXP ‘s’; SELECT shrfirm FROM share WHERE shrfirm NOT REGEXP ‘S’; SELECT shrfirm FROM share WHERE shrfirm NOT REGEXP ‘s|S’; SELECT shrfirm FROM share WHERE shrfirm NOT REGEXP ‘^S’; SELECT shrfirm FROM share WHERE shrfirm NOT REGEXP ‘s$’; A weekly newspaper, sold at supermarket checkouts, frequently reports stories of aliens visiting Earth and taking humans on short trips. Sometimes a captured human sees Elvis commanding the spaceship. To keep track of all these reports, the newspaper has created the following data model. The paper has also supplied some data for the last few sightings and asked you to create the database, add details of these aliens, and answer the following queries: a. What&#39;s the average number of heads of an alien? a. Which alien has the most heads? b. Are there any aliens with a double o in their names? c. How many aliens are chartreuse? d. Report details of all aliens sorted by smell and color. Eduardo, a bibliophile, has a collection of several hundred books. Being a little disorganized, he has his books scattered around his den. They are piled on the floor, some are in bookcases, and others sit on top of his desk. Because he has so many books, he finds it difficult to remember what he has, and sometimes he cannot find the book he wants. Eduardo has a simple personal computer file system that is fine for a single entity or file. He has decided that he would like to list each book by author(s)’ name and type of book (e.g., literature, travel, reference). Draw a data model for this problem, create a single entity table, and write some SQL queries. How do you identify each instance of a book? (It might help to look at a few books.) How should Eduardo physically organize his books to permit fast retrieval of a particular one? Are there any shortcomings with the data model you have created? What is an identifier? Why does a data model have an identifier? What are entities? What is the entity integrity rule? Officially pronounced as “S-Q-L,” but often also pronounced as “sequel”.↩︎ Attributes are shown in italics.↩︎ Now would be a good time to install the MySQL Community server on your computer, unless your instructor has set up a class server.↩︎ SQL keywords are shown in uppercase.↩︎ Preferences &gt; Diagram &gt; Show Column Types↩︎ "],["the-single-entity-1.html", "Chapter 2 The Single Entity The relational model Getting started Modeling a single-entity database Creating a single-table database", " Chapter 2 The Single Entity I want to be alone. Attributed to Greta Garbo Learning Objectives Students completing this chapter will be able to model a single entity; define a single database; write queries for a single-table database. The relational model The relational model introduced by Codd in 1970 is the most popular technology for managing large collections of data. In this chapter, the major concepts of the relational model are introduced. Extensive coverage of the relational model is left until Chapter 8, by which time you will have sufficient practical experience to appreciate fully its usefulness, value, and elegance. A relation, similar to the mathematical concept of a set, is a two-dimensional table arranged in rows and columns. This is a very familiar idea. You have been using tables for many years. A relational database is a collection of relations, where relation is a mathematical term for a table. One row of a table stores details of one observation, instance, or case of an item about which facts are retained—for example, one row for details of a particular student. All the rows in a table store data about the same type of item. Thus, a database might have one table for student data and another table for class data. Similarly, each column in the table contains the same type of data. For example, the first column might record a student’s identification number. A key database design question is to decide what to store in each table. What should the rows and columns contain? In a relational database, each row must be uniquely identified. There must be a primary key, such as student identifier, so that a particular row can be designated. The use of unique identifiers is very common. Telephone numbers and e-mail addresses are examples of unique identifiers. Selection of the primary key, or unique identifier, is another key issue of database design. 💠 Global legal entity identifier (LEI) There is no global standard for identifying legal entities across markets and jurisdictions. The need for such a standard was amplified by Lehman Brothers collapse in 2008. Lehman had 209 registered subsidiaries, legal entities, in 21 countries, and it was party to more than 900,000 derivatives contracts upon its collapse. Key stakeholders, such as financial regulators and Lehman’s creditors, were unable to assess their exposure. Furthermore, others were unable to assess the possible ripple on them of the effects of the collapse because of the transitive nature of many investments (i.e., A owes B, B owes C, and C owes D). The adoption of a global legal entity identifier (LEI), should improve financial system regulation and corporate risk management. Regulators will find it easier to monitor and analyze threats to financial stability and risk managers will be more able evaluate their companies’ risks. The tables in a relational database are connected or related by means of the data in the tables. You will learn, in the next chapter, that this connection is through a pair of values—a primary key and a foreign key. Consider a table of airlines serving a city. When examining this table, you may not recognize the code of an airline, so you then go to another table to find the name of the airline. For example, if you inspect the next table, you find that AM is an international airline serving Atlanta. International airlines serving Atlanta Airline AM JL KX LM MA OS RG SN SR LH LY If you don’t know which airline has the abbreviation AM, then you need to look at the table of airline codes to discover that AeroMexico, with code AM, serves Atlanta. The two tables are related by airline code. Later, you will discover which is the primary key and which is the foreign key. A partial list of airline codes Code Airline AA American Airlines AC Air Canada AD Lone Star Airlines AE Mandarin Airlines AF Air France AG Interprovincial Airlines AI Air India AM AeroMexico AQ Aloha Airlines When designing the relational model, Codd provided commands for processing multiple records at a time. His intention was to increase the productivity of programmers by moving beyond the record-at-a-time processing that is found in most programming languages. Consequently, the relational model supports set processing (multiple records-at-a-time), which is most frequently implemented as Structured Query Language (SQL).6 The relational model separates the logical design of a database from its physical storage. This notion of data independence simplifies data modeling and database programming. In this section, we focus on logical database design, and now that you have had a brief introduction to the relational model, you are ready to learn data modeling. Getting started As with most construction projects, building a relational database must be preceded by a design phase. Data modeling, our design technique, is a method for creating a plan or blueprint of a database. The data model must accurately mirror real-world relationships if it is to support processing business transactions and managerial decision making. Rather than getting bogged down with a theory first, application later approach to database design and use, we will start with application. We will get back to theory when you have some experience in data modeling and database querying. After all, you did not learn to talk by first studying sentence formation; you just started by learning and using simple words. We start with the simplest data model, a single entity, and the simplest database, a single table, as follows. Share code Share name Share price Share quantity Share dividend PE ratio FC Freedonia Copper 27.5 10,529 1.84 16 PT Patagonian Tea 55.25 12,635 2.50 10 AR Abyssinian Ruby 31.82 22,010 1.32 13 SLG Sri Lankan Gold 50.37 32,868 2.68 16 ILZ Indian Lead &amp; Zinc 37.75 6,390 3.00 12 BE Burmese Elephant 0.07 154,713 0.01 3 BS Bolivian Sheep 12.75 231,678 1.78 11 NG Nigerian Geese 35.00 12,323 1.68 10 CS Canadian Sugar 52.78 4,716 2.50 15 ROF Royal Ostrich Farms 33.75 1,234,923 3.00 6 Modeling a single-entity database The simplest database contains information about one entity, which is some real-world thing. Some entities are physical—CUSTOMER, ORDER, and STUDENT; others are abstract or conceptual—WORK ASSIGNMENT, and AUTHORSHIP. We represent an entity by a rectangle: the following figure shows a representation of the entity SHARE. The name of the entity is shown in singular form in uppercase in the top part of the rectangle. The entity SHARE An entity has characteristics or attributes. An attribute is a discrete element of data; it is not usually broken down into smaller components. Attributes are describe the data we want to store. Some attributes of the entity SHARE are share code, share name, share price, share quantity (number owned), share dividend, and PE ratio (price-to-earnings ratio).7 Attributes are shown below the entity’s name. Notice that we refer to share price, rather than price, to avoid confusion if there should be another entity with an attribute called price. Attribute names must be carefully selected so that they are self-explanatory and unique. For example, share dividend is easily recognized as belonging to the entity SHARE. The entity SHARE and its attributes An instance is a particular occurrence of an entity (e.g., facts about Freedonia Copper). To avoid confusion, each instance of an entity needs to be uniquely identified. Consider the case of customer billing. In most cases, a request to bill Smith $100 cannot be accurately processed because a firm might have more than one Smith in its customer file. If a firm has carefully controlled procedures for ensuring that each customer has a unique means of identification, then a request to bill customer number 1789 $100 can be accurately processed. An attribute or collection of attributes that uniquely identifies an instance of an entity is called an identifier. The identifier for the entity SHARE is share code, a unique identifier assigned by the stock exchange to a firm issuing shares. There may be several attributes, or combinations of attributes, that are feasible identifiers for an instance of an entity. Attributes that are identifiers are prefixed by an asterisk. The following figure shows an example of a representation of an entity, its attributes, and identifier. The entity SHARE, its attributes, and identifier Briefly, entities are things in the environment about which we wish to store information. Attributes describe an entity. An entity must have a unique identifier. The modeling language used in this text is designed to record the essential details of a data model. The number of modeling symbols to learn is small, and they preserve all the fundamental concepts of data modeling. Since data modeling often occurs in a variety of settings, the symbols used have been selected so that they can be quickly drawn using pencil-and-paper, whiteboard, or a general-purpose drawing program. This also means that models can be quickly revised as parts can be readily erased and redrawn. The symbols are distinct and visual clutter is minimized because only the essential information is recorded. This also makes the language easy for clients to learn so they can read and amend models. Models can be rapidly translated to a set of tables for a relational database. More importantly, since this text implements the fundamental notions of all data modeling languages, you can quickly convert to another data modeling dialect. Data modeling is a high-level skill, and the emphasis needs to be on learning to think like a data modeler rather than on learning a modeling language. This text’s goal is to get you off to a fast start. ❓ Skill builder A ship has a name, registration code, gross tonnage, and a year of &gt;construction. Ships are classified as cargo or passenger. Draw a data model &gt;for a ship. Creating a single-table database The next stage is to translate the data model into a relational database. The translation rules are very direct: Each entity becomes a table. The entity name becomes the table name. Each attribute becomes a column. The identifier becomes the primary key. The American National Standards Institute’s (ANSI) recommended language for relational database definition and manipulation is SQL, which is both a data definition language (DDL) (to define a database), a data manipulation language (DML) (to query and maintain a database), and a data control language (DCL) (to control access). SQL is a common standard for describing and querying databases and is available with many commercial relational database products, including DB2, Oracle, and Microsoft SQL Server, and open source products such as MySQL and PostgreSQL. In this book, MySQL is the relational database for teaching SQL. Because SQL is a standard, it does not matter which implementation of the relational model you use as the SQL language is common across both the proprietary and open variants.8 SQL uses the CREATE9 statement to define a table. It is not a particularly friendly command, and most products have friendlier interfaces for defining tables. However, it is important to learn the standard, because this is the command that SQL understands. Also, a table definition interface will generate a CREATE statement for execution by SQL. Your interface interactions ultimately translate into a standard SQL command. It is common practice to abbreviate attribute names, as is done in the following example. Defining a table The CREATE command to establish a table called share is as follows: CREATE TABLE share ( shrcode CHAR(3), shrfirm VARCHAR(20) NOT NULL, shrprice DECIMAL(6,2), shrqty DECIMAL(8), shrdiv DECIMAL(5,2), shrpe DECIMAL(2), PRIMARY KEY (shrcode)); Officially pronounced as “S-Q-L,” but often also pronounced as “sequel”.↩︎ Attributes are shown in italics.↩︎ Now would be a good time to install the MySQL Community server on your computer, unless your instructor has set up a class server.↩︎ SQL keywords are shown in uppercase.↩︎ "],["the-one-to-many-relationship.html", "Chapter 3 The One-to-Many Relationship Relationships Creating a database with a 1:m relationship Querying a two-table database Regular expression—pattern matching Subqueries Exercises", " Chapter 3 The One-to-Many Relationship Cow of many—well milked and badly fed. Spanish proverb Learning Objectives Students completing this chapter will be able to model a one-to-many relationship between two entities; define a database with a one-to-many relationship; write queries for a database with a one-to-many relationship. Relationships Entities are not isolated; they are related to other entities. When we move beyond the single entity, we need to identify the relationships between entities to accurately represent the real world. Consider the case where a person’s stocks are listed in different countries. We now need to introduce an entity called NATION. We now have two entities, STOCK and NATION. Consider the relationship between them. A NATION can have many listed stocks. A stock, in this case, is listed in only one nation. There is a 1:m (one-to-many) relationship between NATION and STOCK. A 1:m relationship between two entities is depicted by a line connecting the two with a crow’s foot at the many end of the relationship. The following figure shows the 1:m relationship between NATION and STOCK. This can be read as: “a nation can have many stocks, but a stock belongs to only one nation.” The entity NATION is identified by nation code and has attributes nation name and exchange rate. A 1:m relationship between NATION and STOCK The 1:m relationship occurs frequently in business situations. Sometimes it occurs in a tree or hierarchical fashion. Consider a very hierarchical firm. It has many divisions, but a division belongs to only one firm. A division has many departments, but a department belongs to only one division. A department has many sections, but a section belongs to only one department. A series of 1:m relationships Why did we create an additional entity? Another approach to adding data about listing nation and exchange rate is to add two attributes to STOCK: nation name and exchange rate. At first glance, this seems a very workable solution; however, this will introduce considerable redundancy, as the following table illustrates. The table stock with additional columns *stkcode stkfirm stkprice stkqty stkdiv stkpe natname exchrate FC Freedonia Copper 27.5 10529 1.84 16 United Kingdom 1 PT Patagonian Tea 55.25 12635 2.5 10 United Kingdom 1 AR Abyssinian Ruby 31.82 22010 1.32 13 United Kingdom 1 SLG Sri Lankan Gold 50.37 32868 2.68 16 United Kingdom 1 ILZ Indian Lead &amp; Zinc 37.75 6390 3 12 United Kingdom 1 BE Burmese Elephant 0.07 154713 0.01 3 United Kingdom 1 BS Bolivian Sheep 12.75 231678 1.78 11 United Kingdom 1 NG Nigerian Geese 35 12323 1.68 10 United Kingdom 1 CS Canadian Sugar 52.78 4716 2.5 15 United Kingdom 1 ROF Royal Ostrich Farms 33.75 1234923 3 6 United Kingdom 1 MG Minnesota Gold 53.87 816122 1 25 USA 0.67 GP Georgia Peach 2.35 387333 0.2 5 USA 0.67 NE Narembeen Emu 12.34 45619 1 8 Australia 0.46 QD Queensland Diamond 6.73 89251 0.5 7 Australia 0.46 IR Indooroopilly Ruby 15.92 56147 0.5 20 Australia 0.46 BD Bombay Duck 25.55 167382 1 12 India 0.0228 The exact same nation name and exchange rate pair occurs 10 times for stocks listed in the United Kingdom. This redundancy presents problems when we want to insert, delete, or update data. These problems, generally known as update anomalies, occur with these three basic operations. Insert anomalies We cannot insert a fact about a nation’s exchange rate unless we first buy a stock that is listed in that nation. Consider the case where we want to keep a record of France’s exchange rate and we have no French stocks. We cannot skirt this problem by putting in a null entry for stock details because stkcode, the primary key, would be null, and this is not allowed. If we have a separate table for facts about a nation, then we can easily add new nations without having to buy stocks. This is particularly useful when other parts of the organization, say International Trading, also need access to exchange rates for many nations. Delete anomalies If we delete data about a particular stock, we might also lose a fact about exchange rates. For example, if we delete details of Bombay Duck, we also erase the Indian exchange rate. Update anomalies Exchange rates are volatile. Most companies need to update them every day. What happens when the Australian exchange rate changes? Every row in stock with nation = ‘Australia’ will have to be updated. In a large portfolio, many rows will be changed. There is also the danger of someone forgetting to update all the instances of the nation and exchange rate pair. As a result, there could be two exchange rates for the one nation. If exchange rate is stored in a nation table, however, only one change is necessary, there is no redundancy, and there is no danger of inconsistent exchange rates. Creating a database with a 1:m relationship As before, each entity becomes a table in a relational database, the entity name becomes the table name, each attribute becomes a column, and each identifier becomes a primary key. The 1:m relationship is mapped by adding a column to the entity at the many end of the relationship. The additional column contains the identifier of the one end of the relationship. Consider the relationship between the entities STOCK and NATION. The database has two tables: stock and nation. The table stock has an additional column, natcode, which contains the primary key of nation. If natcode is not stored in stock, then there is no way of knowing the identity of the nation where the stock is listed. A relational database with tables nation and stock nation *natcode natname exchrate AUS Australia 0.46 IND India 0.0228 UK United Kingdom 1 USA United States 0.67 stock *stkcode stkfirm stkprice stkqty stkdiv stkpe natcode FC Freedonia Copper 27.5 10,529 1.84 16 UK PT Patagonian Tea 55.25 12,635 2.5 10 UK AR Abyssinian Ruby 31.82 22,010 1.32 13 UK SLG Sri Lankan Gold 50.37 32,868 2.68 16 UK ILZ Indian Lead &amp; Zinc 37.75 6,390 3 12 UK BE Burmese Elephant 0.07 154,713 0.01 3 UK BS Bolivian Sheep 12.75 231,678 1.78 11 UK NG Nigerian Geese 35 12,323 1.68 10 UK CS Canadian Sugar 52.78 4,716 2.5 15 UK ROF Royal Ostrich Farms 33.75 1,234,923 3 6 UK MG Minnesota Gold 53.87 816,122 1 25 USA GP Georgia Peach 2.35 387,333 0.2 5 USA NE Narembeen Emu 12.34 45,619 1 8 AUS QD Queensland Diamond 6.73 89,251 0.5 7 AUS IR Indooroopilly Ruby 15.92 56,147 0.5 20 AUS BD Bombay Duck 25.55 167,382 1 12 IND Notice that natcode appears in both the stock and nation tables. In nation, natcode is the primary key; it is unique for each instance of nation. In table stock, natcode is a foreign key because it is the primary key of nation, the one end of the 1:m relationship. The column natcode is a foreign key in stock because it is a primary key in nation. A matched primary key–foreign key pair is the method for recording the 1:m relationship between the two tables. This method of representing a relationship is illustrated using shading and arrows for the two USA stocks. In the stock table, natcode is italicized to indicate that it is a foreign key. This method, like asterisking a primary key, is a useful reminder. Although the same name has been used for the primary key and the foreign key in this example, it is not mandatory. The two columns can have different names, and in some cases you are forced to use different names. When possible, we find it convenient to use identical column names to help us remember that the tables are related. To distinguish between columns with identical names, they must by qualified by prefixing the table name. In this case, use nation.natcode and stock.natcode. Thus, nation.natcode refers to the natcode column in the table nation. Although a nation can have many stocks, it is not mandatory to have any. That is, in data modeling terminology, many can be zero, one, or more, but it is mandatory to have a value for natcode in nation for every value of natcode in stock. This requirement, known as the referential integrity constraint, helps maintain the accuracy of a database. Its application means that every foreign key in a table has an identical primary key in that same table or another table. In this example, it means that for every value of natcode in stock, there is a corresponding entry in nation. As a result, a primary key row must be created before its corresponding foreign key row. In other words, details for a nation must be added before any data about its listed stocks are entered. Every foreign key must have a matching primary key (referential integrity rule), and every primary key must be non-null (entity integrity rule). A foreign key cannot be null when a relationship is mandatory, as in the case where a stock must belong to a nation. If a relationship is optional (a person can have a boss), then a foreign key can be null (i.e., a person is the head of the organization, and thus has no boss). The ideas of mandatory and optional will be discussed later in this book. Why is the foreign key in the table at the “many” end of the relationship? Because each instance of stock is associated with exactly one instance of nation. The rule is that a stock must be listed in one, and only one, nation. Thus, the foreign key field is single-valued when it is at the “many” end of a relationship. The foreign key is not at the “one” end of the relationship because each instance of nation can be associated with more than one instance of stock, and this implies a multivalued foreign key. The relational model does not support multivalued fields. Using SQL, the two tables are defined in a similar manner to the way we created a single table in Chapter 3. Here are the SQL statements: CREATE TABLE nation ( natcode CHAR(3), natname VARCHAR(20), exchrate DECIMAL(9,5), PRIMARY KEY(natcode)); CREATE TABLE stock ( stkcode CHAR(3), stkfirm VARCHAR(20), stkprice DECIMAL(6,2), stkqty DECIMAL(8), stkdiv DECIMAL(5,2), stkpe DECIMAL(5), natcode CHAR(3), PRIMARY KEY(stkcode), CONSTRAINT fk_has_nation FOREIGN KEY(natcode) REFERENCES nation(natcode) ON DELETE RESTRICT); Notice that the definition of stock includes an additional phrase to specify the foreign key and the referential integrity constraint. The CONSTRAINT clause defines the column or columns in the table being created that constitute the foreign key. A referential integrity constraint can be named, and in this case, the constraint’s name is fk_has_nation. The foreign key is the column natcode in STOCK, and it references the primary key of nation, which is natcode. The ON DELETE clause specifies what processing should occur if an attempt is made to delete a row in nation with a primary key that is a foreign key in stock. In this case, the ON DELETE clause specifies that it is not permissible (the meaning of RESTRICT) to delete a primary key row in nation while a corresponding foreign key in stock exists. In other words, the system will not execute the delete. You must first delete all corresponding rows in stock before attempting to delete the row containing the primary key. ON DELETE is the default clause for most RDBMSs, so we will dispense with specifying it for future foreign key constraints. Observe that both the primary and foreign keys are defined as CHAR(3). The relational model requires that a primary key–foreign key pair have the same data type and are the same length. ❓ Skill builder The university architect has asked you to develop a data model to record details of campus buildings. A building can have many rooms, but a room can be in only one building. Buildings have names, and rooms have a size and purpose (e.g., lecture, laboratory, seminar). Draw a data model for this situation and create the matching relational database. MySQL Workbench In Workbench, a 1:m relationship is represented in a similar manner to the method you have just learned. Also, note that the foreign key is shown in the entity at the many end with a red diamond. We omit the foreign key when data modeling because it can be inferred. You will observe some additional symbols on the line between the two entities, and these will be explained later, but take note of the crow’s foot indicating the 1:m relationship between nation and stock. Because Workbench can generate automatically the SQL to create the tables,10 we use lowercase table names and abbreviated column names. Specifying a 1:m relationship in MySQL Workbench Querying a two-table database A two-table database offers the opportunity to learn more SQL and another relational algebra operation: join. Join Join creates a new table from two existing tables by matching on a column common to both tables. Usually, the common column is a primary key–foreign key pair: The primary key of one table is matched with the foreign key of another table. Join is frequently used to get the data for a query into a single row. Consider the tables nation and stock. If we want to calculate the value—in British pounds—of a stock, we multiply stock price by stock quantity and then exchange rate. To find the appropriate exchange rate for a stock, get its natcode from stock and then find the exchange rate in the matching row in nation, the one with the same value for natcode. For example, to calculate the value of Georgia Peach, which has natcode = ‘US’, find the row in nation that also has natcode = ‘US’. In this case, the stock’s value is 2.35 * 387333 / 0.67 = £609,855.81. Calculation of stock value is very easy once a join is used to get the three values in one row. The SQL command for joining the two tables is: SELECT * FROM stock JOIN nation ON stock.natcode = nation.natcode; Table 3.1: Displaying records 1 - 10 stkcode stkfirm stkprice stkqty stkdiv stkpe natcode natcode natname exchrate IR Indooroopilly Ruby 15.92 56147 0.50 20 AUS AUS Australia 0.4600 NE Narembeen Emu 12.34 45619 1.00 8 AUS AUS Australia 0.4600 QD Queensland Diamond 6.73 89251 0.50 7 AUS AUS Australia 0.4600 BD Bombay Duck 25.55 167382 1.00 12 IND IND India 0.0228 AR Abyssinian Ruby 31.82 22010 1.32 13 UK UK United Kingdom 1.0000 BE Burmese Elephant 0.07 154713 0.01 3 UK UK United Kingdom 1.0000 BS Bolivian Sheep 12.75 231678 1.78 11 UK UK United Kingdom 1.0000 CS Canadian Sugar 52.78 4716 2.50 15 UK UK United Kingdom 1.0000 FC Freedonia Copper 27.50 10529 1.84 16 UK UK United Kingdom 1.0000 ILZ Indian Lead &amp; Zinc 37.75 6390 3.00 12 UK UK United Kingdom 1.0000 The join of stock and nation The columns stkprice and stkdiv record values in the country’s currency. Thus, the price of Bombay Duck is 25.55 Indian rupees. To find the value in U.K. pounds (GPB), multiply the price by 0.0228, because one rupee is worth 0.0228 GPB. The value of one share of Bombay Duck in U.S. dollars (USD) is 25.55 * 0.0228 / 0.67 because one USD is worth 0.67 GBP. There are several things to notice about the SQL command and the result: To avoid confusion because natcode is a column name in both stock and nation, it needs to be qualified. If natcode is not qualified, the system will reject the query because it cannot distinguish between the two columns titled natcode. The new table has the natcode column replicated. Both are called natcode. The naming convention for the replicated column varies with the RDBMS. The columns, for example, should be labeled stock.natcode and nation.natcode. The SQL command specifies the names of the tables to be joined, the columns to be used for matching, and the condition for the match (equality in this case). The number of columns in the new table is the sum of the columns in the two tables. The stock value calculation is now easily specified in an SQL command because all the data are in one row. Remember that during data modeling we created two entities, STOCK and NATION, and defined the relationship between them. We showed that if the data were stored in one table, there could be updating problems. Now, with a join, we have combined these data. So why separate the data only to put them back together later? There are two reasons. First, we want to avoid update anomalies. Second, as you will discover, we do not join the same tables every time. Join comes in several flavors. The matching condition can be =, &lt;&gt;, &lt;=, &lt;, &gt;=, and &gt;. This generalized version is called a theta join. Generally, when people refer to a join, they mean an equijoin, when the matching condition is equality. A join can be combined with other SQL commands. Report the value of each stockholding in UK pounds. Sort the report by nation and firm. SELECT natname, stkfirm, stkprice, stkqty, exchrate, stkprice*stkqty*exchrate as stkvalue FROM stock JOIN nation ON stock.natcode = nation.natcode ORDER BY natname, stkfirm; Table 3.2: Displaying records 1 - 10 natname stkfirm stkprice stkqty exchrate stkvalue Australia Indooroopilly Ruby 15.92 56147 0.4600 411175.71 Australia Narembeen Emu 12.34 45619 0.4600 258951.69 Australia Queensland Diamond 6.73 89251 0.4600 276303.25 India Bombay Duck 25.55 167382 0.0228 97506.71 United Kingdom Abyssinian Ruby 31.82 22010 1.0000 700358.20 United Kingdom Bolivian Sheep 12.75 231678 1.0000 2953894.50 United Kingdom Burmese Elephant 0.07 154713 1.0000 10829.91 United Kingdom Canadian Sugar 52.78 4716 1.0000 248910.48 United Kingdom Freedonia Copper 27.50 10529 1.0000 289547.50 United Kingdom Indian Lead &amp; Zinc 37.75 6390 1.0000 241222.50 Control break reporting The purpose of a join is to collect the necessary data for a report. When two tables in a 1:m relationship are joined, the report will contain repetitive data. If you re-examine the report from the previous join, you will see that nation and exchrate are often repeated because the same values apply to many stocks. A more appropriate format is shown in the following figure, an example of a control break report. Nation Exchange rate Firm Price Quantity Value Australia 0.46 Indooroopilly Ruby 15.92 56,147 411,175.71 Narembeen Emu 12.34 45,619 258,951.69 Queensland Diamond 6.73 89,251 276,303.25 India 0.0228 Bombay Duck 25.55 167,382 97,506.71 United Kingdom 0.0228 Abyssinian Ruby 31.82 22,010 700,358.20 Bolivian Sheep 12.75 231,678 2,953,894.50 Burmese Elephant 0.07 154,713 10,829.91 Canadian Sugar 52.78 4,716 248,910.48 Freedonia Copper 27.50 10,529 289,547.50 Indian Lead &amp; Zinc 37.75 6,390 241,222.50 Nigerian Geese 35.00 12,323 431,305.00 Patagonian Tea 55.25 12,635 698,083.75 Royal Ostrich Farms 33.75 1,234,923 41,678,651.25 Sri Lankan Gold 50.37 32,868 1,655,561.16 United States 0.0228 Georgia Peach 2.35 387,333 609,855.81 Minnesota Gold 53.87 816,122 29,456,209.73 A control break report recognizes that the values in a particular column or columns seldom change. In this case, natname and exchrate are often the same from one row to the next, so it makes sense to report these data only when they change. The report is also easier to read. The column natname is known as a control field. Notice that there are four groups of data, because natname has four different values. Many RDBMS packages have report-writing languages to facilitate creating a control break report. These languages typically support summary reporting for each group of rows having the same value for the control field(s). A table must usually be sorted on the control break field(s) before the report is created. GROUP BY—reporting by groups The GROUP BY clause is an elementary form of control break reporting. It permits grouping of rows that have the same value for a specified column or columns, and it produces one row for each different value of the grouping column(s). Report by nation the total value of stockholdings. SELECT natname, sum(stkprice*stkqty*exchrate) as stkvalue FROM stock JOIN nation ON stock.natcode = nation.natcode GROUP BY natname; Table 3.3: 4 records natname stkvalue Australia 946430.65 India 97506.71 United Kingdom 48908364.25 United States 30066065.54 SQL’s built-in functions (COUNT, SUM, AVERAGE, MIN, and MAX) can be used with the GROUP BY clause. They are applied to a group of rows having the same value for a specified column. You can specify more than one function in a SELECT statement. For example, we can compute total value and number of different stocks and group by nation using: Report the number of stocks and their total value by nation. SELECT natname, COUNT(*), SUM(stkprice*stkqty*exchrate) AS stkvalue FROM stock JOIN nation ON stock.natcode = nation.natcode GROUP BY natname; Table 3.4: 4 records natname COUNT(*) stkvalue Australia 3 946430.65 India 1 97506.71 United Kingdom 10 48908364.25 United States 2 30066065.54 You can group by more than one column name; however, all column names appearing in the SELECT clause must be associated with a built-in function or be in a GROUP BY clause. List stocks by nation, and for each nation show the number of stocks for each PE ratio and the total value of those stock holdings in UK pounds. SELECT natname,stkpe,COUNT(*), SUM(stkprice*stkqty*exchrate) AS stkvalue FROM stock JOIN nation ON stock.natcode = nation.natcode GROUP BY natname, stkpe; Table 3.5: Displaying records 1 - 14 natname stkpe COUNT(*) stkvalue Australia 20 1 411175.71 Australia 8 1 258951.69 Australia 7 1 276303.25 India 12 1 97506.71 United Kingdom 13 1 700358.20 United Kingdom 3 1 10829.91 United Kingdom 11 1 2953894.50 United Kingdom 15 1 248910.48 United Kingdom 16 2 1945108.66 United Kingdom 12 1 241222.50 United Kingdom 10 2 1129388.75 United Kingdom 6 1 41678651.25 United States 5 1 609855.81 United States 25 1 29456209.73 In this example, stocks are grouped by both natname and stkpe. In most cases, there is only one stock for each pair of natname and stkpe; however, there are two situations (U.K. stocks with PEs of 10 and 16) where details of multiple stocks are grouped into one report line. Examining the values in the COUNT column helps you to identify these stocks. HAVING—the WHERE clause of groups The HAVING clause in a GROUP BY is like the WHERE clause in a SELECT. It restricts the number of groups reported, whereas WHERE restricts the number of rows reported. Used with built-in functions, HAVING is always preceded by GROUP BY and is always followed by a function (SUM, AVG, MAX, MIN, or COUNT). Report the total value of stocks for nations with two or more listed stocks. SELECT natname, SUM(stkprice*stkqty*exchrate) AS stkvalue FROM stock JOIN nation ON stock.natcode = nation.natcode GROUP BY natname HAVING COUNT(*) &gt;= 2; Table 3.6: 3 records natname stkvalue Australia 946430.6 United Kingdom 48908364.2 United States 30066065.5 ❓ Skill builder Report by nation the total value of dividends. Regular expression—pattern matching Regular expression was introduced in the previous chapter, and we will now continue to learn some more of its features. Search for a string not containing specified characters The ^ (carat) is the symbol for NOT. It is used when we want to find a string not containing a character in one or more specified strings. For example, [^a-f] means any character not in the set containing a, b, c, d, e, or f. List the names of nations with non-alphabetic characters in their names SELECT natname FROM nation WHERE natname REGEXP &#39;[^a-z|A-Z]&#39; Table 3.7: 2 records natname United Kingdom United States Notice that the nations reported have a space in their name, which is a character not in the range a-z and not in A-Z. Search for string containing a repeated pattern or repetition A pair of curly brackets is used to denote the repetition factor for a pattern. For example, {n} means repeat a specified pattern n times. List the names of firms with a double ‘e’. SELECT stkfirm FROM stock WHERE stkfirm REGEXP &#39;[e]{2}&#39;; Table 3.8: 5 records stkfirm Bolivian Sheep Freedonia Copper Narembeen Emu Nigerian Geese Queensland Diamond Search combining alternation and repetition Regular expressions becomes very powerful when you combine several of the basic capabilities into a single search expression. List the names of firms with a double ‘s’ or a double ‘n’. SELECT stkfirm FROM stock WHERE stkfirm REGEXP &#39;[s]{2}|[n]{2}&#39;; Table 3.9: 2 records stkfirm Abyssinian Ruby Minnesota Gold Search for multiple versions of a string If you are interested in find a string containing several specified string, you can use the square brackets to indicate the sought strings. For example, [ea] means any character from the set containing e and a. List the names of firms with names that include ‘inia’ or ‘onia’. SELECT stkfirm FROM stock WHERE stkfirm REGEXP &#39;[io]nia&#39;; Table 3.10: 3 records stkfirm Abyssinian Ruby Freedonia Copper Patagonian Tea Search for a string in a particular position Sometimes you might be interested in identifying a string with a character in a particular position. Find firms with ‘t’ as the third letter of their name. SELECT stkfirm FROM stock WHERE stkfirm REGEXP &#39;^(.){2}t&#39;; Table 3.11: 1 records stkfirm Patagonian Tea The regular expression has three elements: ^ indicates start searching at the beginning of the string; (.){2} specifies that anything is acceptable for the next two characters; t indicates what the next character, the third, must be. Search for a string not containing any specified characters There might be a need to find rows not containing specified characters anywhere in a givev coumn. You need to check every character in the string to ensure there are matches. List the names of nations without s or S anywhere in their names SELECT * FROM nation WHERE natname REGEXP &#39;^[^s|S]*$&#39; Table 3.12: 2 records natcode natname exchrate IND India 0.0228 UK United Kingdom 1.0000 ^ start searching at the beginning of the string; $ end searching at the end of the string; * any character in a string; ^s|S no lower or upper case s. You have seen a few of the features of a very powerful tool. To learn more about regular expressions, see regexlib.com, which contains a library of regular expressions and a feature for finding expressions to solve specific problems. Check out the regular expression for checking whether a character string is a valid email address. Subqueries A subquery, or nested SELECT, is a SELECT nested within another SELECT. A subquery can be used to return a list of values subsequently searched with an IN clause. Report the names of all Australian stocks. SELECT stkfirm FROM stock WHERE natcode IN (SELECT natcode FROM nation WHERE natname = &#39;Australia&#39;); Table 3.13: 3 records stkfirm Indooroopilly Ruby Narembeen Emu Queensland Diamond Conceptually, the subquery is evaluated first. It returns a list of values for natcode (‘AUS’) so that the query then is the same as: SELECT stkfirm FROM stock WHERE natcode IN (&#39;AUS&#39;); When discussing subqueries, sometimes a subquery is also called an inner query. The term outer query is applied to the SQL preceding the inner query. In this case, the outer and inner queries are: Outer query SELECT stkfirm FROM stock WHERE natcode IN Inner query (SELECT natcode FROM nation WHERE natname = ‘Australia’); Note that in this case we do not have to qualify natcode. There is no identity crisis, because natcode in the inner query is implicitly qualified as nation.natcode and natcode in the outer query is understood to be stock.natcode. This query also can be run as a join by writing: SELECT stkfirm FROM stock JOIN nation ON stock.natcode = nation.natcode AND natname = &#39;Australia&#39;; Correlated subquery In a correlated subquery, the subquery cannot be evaluated independently of the outer query. It depends on the outer query for the values it needs to resolve the inner query. The subquery is evaluated for each value passed to it by the outer query. An example illustrates when you might use a correlated subquery and how it operates. Find those stocks where the quantity is greater than the average for that country. An approach to this query is to examine the rows of stock one a time, and each time compare the quantity of stock to the average for that country. This means that for each row, the subquery must receive the outer query’s country code so it can compute the average for that country. SELECT natname, stkfirm, stkqty FROM stock JOIN nation ON stock.natcode = nation.natcode WHERE stkqty &gt; (SELECT avg(stkqty) FROM stock WHERE stock.natcode = nation.natcode); Table 3.14: 4 records natname stkfirm stkqty Australia Queensland Diamond 89251 United Kingdom Bolivian Sheep 231678 United Kingdom Royal Ostrich Farms 1234923 United States Minnesota Gold 816122 Conceptually, think of this query as stepping through the join of stock and nation one row at a time and executing the subquery each time. The first row has natcode = ‘AUS’ so the subquery becomes SELECT AVG(stkqty) FROM stock WHERE stock.natcode = &#39;AUS&#39;; Since the average stock quantity for Australian stocks is 63,672.33, the first row in the join, Narembeen Emu, is not reported. Neither is the second row reported, but the third is. The term correlated subquery is used because the inner query’s execution depends on receiving a value for a variable (nation.natcode in this instance) from the outer query. Thus, the inner query of the correlated subquery cannot be evaluated once and for all. It must be evaluated repeatedly—once for each value of the variable received from the outer query. In this respect, a correlated subquery is different from a subquery, where the inner query needs to be evaluated only once. The requirement to compare each row of a table against a function (e.g., average or count) for some rows of a column is usually a clue that you need to write a correlated subquery. ❓ Skill builder Why are no Indian stocks reported in the correlated subquery example? How would you change the query to report an Indian stock? Report only the three stocks with the largest quantities (i.e., do the query without using ORDER BY). Views—virtual tables You might have noticed that in these examples we repeated the join and stock value calculation for each query. Ideally, we should do this once, store the result, and be able to use it with other queries. We can do so if we create a view, a virtual table. A view does not physically exist as stored data; it is an imaginary table constructed from existing tables as required. You can treat a view as if it were a table and write SQL to query it. A view contains selected columns from one or more tables. The selected columns can be renamed and rearranged. New columns based on arithmetic expressions can be created. GROUP BY can also be used when creating a view. Remember, a view contains no actual data. It is a virtual table. This SQL command does the join, calculates stock value, and saves the result as a view: CREATE VIEW stkvalue (nation, firm, price, qty, exchrate, value) AS SELECT natname, stkfirm, stkprice, stkqty, exchrate, stkprice*stkqty*exchrate FROM stock JOIN nation ON stock.natcode = nation.natcode; There are several things to notice about creating a view: The six names enclosed in parentheses are the column names for the view. There is a one-to-one correspondence between the names in parentheses and the names or expressions in the SELECT clause. Thus the view column named value contains the result of the arithmetic expression stkprice * stkqty * exchrate. A view can be used in a query, such as: Find stocks with a value greater than £100,000. SELECT nation, firm, value FROM stkvalue WHERE value &gt; 100000; Table 3.15: Displaying records 1 - 10 nation firm value Australia Indooroopilly Ruby 411175.7 Australia Narembeen Emu 258951.7 Australia Queensland Diamond 276303.2 United Kingdom Abyssinian Ruby 700358.2 United Kingdom Bolivian Sheep 2953894.5 United Kingdom Canadian Sugar 248910.5 United Kingdom Freedonia Copper 289547.5 United Kingdom Indian Lead &amp; Zinc 241222.5 United Kingdom Nigerian Geese 431305.0 United Kingdom Patagonian Tea 698083.8 There are two main reasons for creating a view. First, as we have seen, query writing can be simplified. If you find that you are frequently writing the same section of code for a variety of queries, then isolate the common section and put it in a view. This means that you will usually create a view when a fact, such as stock value, is derived from other facts in the table. The second reason is to restrict access to certain columns or rows. For example, the person who updates stock could be given a view that excludes stkqty. In this case, changes in stock prices could be updated without revealing confidential information, such as the value of the stock portfolio. ❓ Skill builder How could you use a view to solve the following query that was used when discussing the correlated subquery? Find those stocks where the quantity is greater than the average for that country. Summary Entities are related to other entities by relationships. The 1:m (one-to-many) relationship occurs frequently in data models. An additional entity is required to represent a 1:m relationship to avoid update anomalies. In a relational database, a 1:m relationship is represented by an additional column, the foreign key, in the table at the many end of the relationship. The referential integrity constraint insists that a foreign key must always exist as a primary key in a table. A foreign key constraint is specified in a CREATE statement. Join creates a new table from two existing tables by matching on a column common to both tables. Often the common column is a primary key–foreign key combination. A theta-join can have matching conditions of =, &lt;&gt;, &lt;=, &lt;, &gt;=, and &gt;. An equijoin describes the situation where the matching condition is equality. The GROUP BY clause is used to create an elementary control break report. The HAVING clause of GROUP BY is like the WHERE clause of SELECT. A subquery, which has a SELECT statement within another SELECT statement, causes two SELECT statements to be executed—one for the inner query and one for the outer query. A correlated subquery is executed as many times as there are rows selected by the outer query. A view is a virtual table that is created when required. Views can simplify report writing and restrict access to specified columns or rows. Key terms and concepts Constraint JOIN Control break reporting One-to-many (1:m) relationship Correlated subquery Referential integrity Delete anomalies Relationship Equijoin Theta-join Foreign key Update anomalies GROUP BY Views HAVING Virtual table Insert anomalies Exercises Draw data models for the following situations. In each case, make certain that you show the attributes and feasible identifiers: A farmer can have many cows, but a cow belongs to only one farmer. A university has many students, and a student can attend at most one university. An aircraft can have many passengers, but a passenger can be on only one flight at a time. A nation can have many states and a state many cities. An art researcher has asked you to design a database to record details of artists and the museums in which their paintings are displayed. For each painting, the researcher wants to know the size of the canvas, year painted, title, and style. The nationality, date of birth, and death of each artist must be recorded. For each museum, record details of its location and specialty, if it has one. Report all values in British pounds: Report the value of stocks listed in Australia. Report the dividend payment of all stocks. Report the total dividend payment by nation. Create a view containing nation, firm, price, quantity, exchange rate, value, and yield. Report the average yield by nation. Report the minimum and maximum yield for each nation. Report the nations where the average yield of stocks exceeds the average yield of all stocks. How would you change the queries in exercise 4-2 if you were required to report the values in American dollars, Australian dollars, or Indian rupees? What is a foreign key and what role does it serve? What is the referential integrity constraint? Why should it be enforced? Kisha, against the advice of her friends, is simultaneously studying data management and Shakespearean drama. She thought the two subjects would be an interesting contrast. However, the classes are very demanding and often enter her midsummer dreams. Last night, she dreamed that William Shakespeare wanted her to draw a data model. He explained, before she woke up in a cold sweat, that a play had many characters but the same character never appeared in more than one play. “Methinks,” he said, “the same name may have appeareth more than the once, but ’twas always a person of a different ilk.” He then, she hazily recollects, went on to spout about the quality of data dropping like the gentle rain. Draw a data model to keep old Bill quiet and help Kisha get some sleep. An orchestra has four broad classes of instruments (strings, woodwinds, brass, and percussion). Each class contains musicians who play different instruments. For example, the strings section of a full symphony orchestra contains 2 harps, 16 to 18 first violins, 14 to 16 second violins, 12 violas, 10 cellos, and 8 double basses. A city has asked you to develop a database to store details of the musicians in its three orchestras. All the musicians are specialists and play only one instrument for one orchestra. Answer the following queries based on the following database for a car dealer: What is the personid of Sheila O’Hara? List sales personnel sorted by last name and within last name, first name. List details of the sales made by Bruce Bush. List details of all sales showing the gross profit (selling price minus cost price). Report the number of cars sold of each type. What is the average selling price of cars sold by Sue Lim? Report details of all sales where the gross profit is less than the average. What was the maximum selling price of any car? What is the total gross profit? Report the gross profit made by each salesperson who sold at least three cars. Create a view containing all the details in the car table and the gross profit Find stocks where the third or fourth letter in their name is an ‘m’. An electricity supply company needs a database to record details of solar panels installed on its customers’ homes so it can estimate how much solar energy will be generated based on the forecast level of solar radiation for each house’s location. A solar panel has an area, measured in square meters, and an efficiency expressed as a percentage (e.g., 22% efficiency means that 22% of the incident solar energy is converted into electrical energy). Create a data model. How will you identify each customer and each panel? Database &gt; Forward Engineer…↩︎ "],["the-many-to-many-relationship.html", "Chapter 4 The Many-to-Many Relationship The many-to-many relationship Creating a relational database with an m:m relationship Querying an m:m relationship Key terms and concepts Exercises", " Chapter 4 The Many-to-Many Relationship Fearful concatenation of circumstances. Daniel Webster Learning objectives Students completing this chapter will be able to model a many-to-many relationship between two entities; define a database with a many-to-many relationship; write queries for a database with a many-to-many relationship. The many-to-many relationship Consider the case when items are sold. We can immediately identify two entities: SALE and ITEM. A sale can contain many items, and an item can appear in many sales. We are not saying the same item can be sold many times, but the particular type of item (e.g., a compass) can be sold many times; thus we have a many-to-many (m:m) relationship between SALE and ITEM. When we have an m:m relationship, we create a third entity to link the entities through two 1:m relationships. Usually, it is fairly easy to name this third entity. In this case, this third entity, typically known as an associative entity, is called LINE ITEM. A typical old style sales form lists the items purchased by a customer. Each of the lines appearing on the order form is generally known in retailing as a line item, which links an item and a sale. A sales form The representation of this m:m relationship is shown. We say many-to-many because there are two relationships—an ITEM is related to many SALEs, and a SALE is related to many ITEMs. This data model can also be read as: “a sale has many line items, but a line item refers to only one sale. Similarly, an item can appear as many line items, but a line item references only one item.” An m:m relationship between SALE and ITEM The entity SALE is identified by saleno and has the attributes saledate and saletext (a brief comment on the customer—soft information). LINEITEM is partially identified by lineno and has attributes lineqty (the number of units sold) and lineprice (the unit selling price for this sale). ITEM is identified by itemno and has attributes itemname, itemtype (e.g., clothing, equipment, navigation aids, furniture, and so on), and itemcolor. If you look carefully at the m:m relationship figure, you will notice that there is a plus sign (+) above the crow’s foot at the “many” end of the 1:m relationship between SALE and LINEITEM. This plus sign provides information about the identifier of LINEITEM. As you know, every entity must have a unique identifier. A sales order is a series of rows or lines, and lineno is unique only within a particular order. If we just use lineno as the identifier, we cannot guarantee that every instance of LINEITEM is unique. If we use saleno and lineno together, however, we have a unique identifier for every instance of LINEITEM. Identifier saleno is unique for every sale, and lineno is unique within any sale. The plus indicates that LINEITEM’s unique identifier is the concatenation of saleno and lineno. The order of concatenation does not matter. LINEITEM is termed a weak entity because it relies on another entity for its existence and identification. MySQL Workbench Workbench automatically creates an associative entity for an m:m relationship and populates it with a composite primary key based on concatenating the primary keys of the two entities forming the m:m relationship. First, draw the two tables and enter their respective primary keys and columns. Second, select the m:m symbol and connect the two tables through clicking on one and dragging to the second and releasing. You can then modify the associative entity as required, such as changing its primary key. The capability to automatically create an associative entity for an m:m relationship is a very useful Workbench feature. An m:m relationship with Workbench Workbench distinguishes between two types of relationships. An identifying relationship, shown by a solid line, is used when the entity at the many end of the relationship is a weak entity and needs the identifier of the one end of the relationship to uniquely identify an instance of the relationship, as in LINEITEM. An identifying relationship corresponds to the + sign associated with a crow’s foot. The other type of relationship, shown by a dashed line, is known as a non-identifying relationship. The mapping between the type of relationship and the representation (i.e., dashed or solid line) is arbitrary and thus not always easily recalled. We think that using a + on the crow’s foot is a better way of denoting weak entities. When the relationship between SALE and ITEM is drawn in Workbench, as shown in the following figure, there are two things to notice. First, the table, lineitem, maps the associative entity generated for the m:m relationship. Second, lineitem has an identifying relationship with sale and a non-identifying relationship with item. An m:m relationship between SALE and ITEM in MySQL Workbench Why did we create a third entity? When we have an m:m relationship, we create an associative entity to store data about the relationship. In this case, we have to store data about the items sold. We cannot store the data with SALE because a sale can have many items, and an instance of an entity stores only single-value facts. Similarly, we cannot store data with ITEM because an item can appear in many sales. Since we cannot store data in SALE or ITEM, we must create another entity to store data about the m:m relationship. You might find it useful to think of the m:m relationship as two 1:m relationships. An item can appear on many line item listings, and a line item entry refers to only one item. A sale has many line items, and each line item entry refers to only one sale. Social Security number is notunique! Two girls named Sarah Lee Ferguson were born on May 3, 1959. The U.S. government considered them one and the same and issued both the same Social Security number (SSN), a nine-digit identifier of U.S. residents. Now Sarah Lee Ferguson Boles and Sarah Lee Ferguson Johnson share the same SSN.11 Mrs. Boles became aware of her SSN twin in 1987 when the Internal Revenue Service claimed there was a discrepancy in her reported income Because SSN is used as an identifier in IRS systems. Mrs. Boles encountered other incidents of mistaken identity. Some of Mrs. Johnson’s purchases appeared on Mrs. Boles’ credit reports. In late 1989, the Social Security Administration notified Mrs. Boles that her original number was given to her in error and she had to provide evidence of her age, identity, and citizenship to get a new number. When Mrs. Boles got her new SSN, it is likely she had to also get a new driver’s license and establish a new credit history. Creating a relational database with an m:m relationship As before, each entity becomes a table in a relational database, the entity name becomes the table name, each attribute becomes a column, and each identifier becomes a primary key. Remember, a 1:m relationship is mapped by adding a column to the entity of the many end of the relationship. The new column contains the identifier of the one end of the relationship. Conversion of the foregoing data model results in the three tables following. Note the one-to-one correspondence between attributes and columns for sale and item. Observe the lineitem has two additional columns, saleno and itemno. Both of these columns are foreign keys in lineitem (remember the use of italics to signify foreign keys). Two foreign keys are required to record the two 1:m relationships. Notice in lineitem that saleno is both part of the primary key and a foreign key. Tables sale, lineitem, and item *saleno saledate saletext 1 2020-01-15 Scruffy Australian—called himself Bruce. 2 2020-01-15 Man. Rather fond of hats. 3 2020-01-15 Woman. Planning to row Atlantic—lengthwise! 4 2020-01-15 Man. Trip to New York—thinks NY is a jungle! 5 2020-01-16 Expedition leader for African safari. *lineno lineqty lineprice *saleno itemno 1 1 4.50 1 2 1 1 25.00 2 6 2 1 20.00 2 16 3 1 25.00 2 19 4 1 2.25 2 2 1 1 500.00 3 4 2 1 2.25 3 2 1 1 500.00 4 4 2 1 65.00 4 9 3 1 60.00 4 13 4 1 75.00 4 14 5 1 10.00 4 3 6 1 2.25 4 2 1 50 36.00 5 10 2 50 40.50 5 11 3 8 153.00 5 12 4 1 60.00 5 13 5 1 0.00 5 2 *itemno itemname itemtype itemcolor 1 Pocket knife—Nile E Brown 2 Pocket knife—Avon E Brown 3 Compass N — 4 Geopositioning system N — 5 Map measure N — 6 Hat—Polar Explorer C Red 7 Hat—Polar Explorer C White 8 Boots—snake proof C Green 9 Boots—snake proof C Black 10 Safari chair F Khaki 11 Hammock F Khaki 12 Tent—8 person F Khaki 13 Tent—2 person F Khaki 14 Safari cooking kit E — 15 Pith helmet C Khaki 16 Pith helmet C White 17 Map case N Brown 18 Sextant N — 19 Stetson C Black 20 Stetson C Brown The SQL commands to create the three tables are as follows: CREATE TABLE sale ( saleno INTEGER, saledate DATE NOT NULL, saletext VARCHAR(50), PRIMARY KEY(saleno)); CREATE TABLE item ( itemno INTEGER, itemname VARCHAR(30) NOT NULL, itemtype CHAR(1) NOT NULL, itemcolor VARCHAR(10), PRIMARY KEY(itemno)); CREATE TABLE lineitem ( lineno INTEGER, lineqty INTEGER NOT NULL, lineprice DECIMAL(7,2) NOT NULL, saleno INTEGER, itemno INTEGER, PRIMARY KEY(lineno,saleno), CONSTRAINT fk_has_sale FOREIGN KEY(saleno) REFERENCES sale(saleno), CONSTRAINT fk_has_item FOREIGN KEY(itemno) REFERENCES item(itemno)); Although the sale and item tables are created in a similar fashion to previous examples, there are two things to note about the definition of lineitem. First, the primary key is a composite of lineno and saleno, because together they uniquely identify an instance of lineitem. Second, there are two foreign keys, because lineno is at the “many” end of two 1: m relationships. ❓ Skill builder A hamburger shop makes several types of hamburgers, and the same type of ingredient can be used with several types of hamburgers. This does not literally mean the same piece of lettuce is used many times, but lettuce is used with several types of hamburgers. Draw the data model for this situation. What is a good name for the associative entity? Querying an m:m relationship A three-table join The join operation can be easily extended from two tables to three or more merely by specifying the tables to be joined and the matching conditions. For example: SELECT * FROM sale JOIN lineitem ON sale.saleno = lineitem.saleno JOIN item ON item.itemno = lineitem.itemno; There are two matching conditions: one for sale and lineitem (sale.saleno = lineitem.saleno) and one for the item and lineitem tables (item.itemno = lineitem.itemno). The table lineitem is the link between sale and item and must be referenced in both matching conditions. You can tailor the join to be more precise and report some columns rather than all. List the name, quantity, price, and value of items sold on January 16, 2011. SELECT itemname, lineqty, lineprice, lineqty*lineprice AS total FROM sale, lineitem, item WHERE lineitem.saleno = sale.saleno AND item.itemno = lineitem.itemno AND saledate = &#39;2011-01-16&#39;; Table 4.1: 5 records itemname lineqty lineprice total Safari chair 50 36.0 1800 Hammock 50 40.5 2025 Tent - 8 person 8 153.0 1224 Tent - 2 person 1 60.0 60 Pocket knife - Avon 1 0.0 0 EXISTS—does a value exist EXISTS is used in a WHERE clause to test whether a table contains at least one row satisfying a specified condition. It returns the value true if and only if some row satisfies the condition; otherwise it returns false. EXISTS represents the existential quantifier of formal logic. The best way to get a feel for EXISTS is to examine a query. Report all clothing items (type “C”) for which a sale is recorded. SELECT itemname, itemcolor FROM item WHERE itemtype = &#39;C&#39; AND EXISTS (SELECT * FROM lineitem WHERE lineitem.itemno = item.itemno); Table 4.2: 4 records itemname itemcolor Hat - Polar explorer Red Boots - snake proof Black Pith helmet White Stetson Black Conceptually, we can think of this query as evaluating the subquery for each row of item. The first item with itemtype = ‘C’, Hat—Polar Explorer (red), in item has itemno = 6. Thus, the query becomes SELECT itemname, itemcolor FROM item WHERE itemtype = &#39;C&#39; AND EXISTS (SELECT * FROM lineitem WHERE lineitem.itemno = 6); Because there is at least one row in lineitem with itemno = 6, the subquery returns true. The item has been sold and should be reported. The second clothing item, Hat—Polar Explorer (white), in item has itemno = 7. There are no rows in lineitem with itemno = 7, so the subquery returns false. That item has not been sold and should not be reported. You can also think of the query as, “Select clothing items for which a sale exists.” Remember, for EXISTS to return true, there needs to be only one row for which the condition is true. NOT EXISTS—select a value if it does not exist NOT EXISTS is the negative of EXISTS. It is used in a WHERE clause to test whether all rows in a table fail to satisfy a specified condition. It returns the value true if there are no rows satisfying the condition; otherwise it returns false. Report all clothing items that have not been sold. SELECT itemname, itemcolor FROM item WHERE itemtype = &#39;C&#39; AND NOT EXISTS (SELECT * FROM lineitem WHERE item.itemno = lineitem.itemno); Table 4.3: 4 records itemname itemcolor Hat - Polar explorer White Boots - snake proof Green Pith helmet Khaki Stetson Brown You can also think of the query as, “Select clothing items for which no sales exist.” Also remember, for NOT EXISTS to return true, no rows should satisfy the condition. ❓ Skill builder Report all red items that have not been sold. Write the query twice, once using EXISTS and once without EXISTS. Divide (and be conquered) In addition to the existential quantifier that you have already encountered, formal logic has a universal quantifier known as forall that is necessary for queries such as Find the items that have appeared in all sales. If a universal quantifier were supported by SQL, this query could be phrased as, “Select item names where forall sales there exists a lineitem row recording that this item was sold.” A quick inspection of the first set of tables shows that one item satisfies this condition (itemno = 2). While SQL does not directly support the universal quantifier, formal logic shows that forall can be expressed using EXISTS. The query becomes, “Find items such that there does not exist a sale in which this item does not appear.” The equivalent SQL expression is SELECT itemno, itemname FROM item WHERE NOT EXISTS (SELECT * FROM sale WHERE NOT EXISTS (SELECT * FROM lineitem WHERE lineitem.itemno = item.itemno AND lineitem.saleno = sale.saleno)); Table 4.4: 1 records itemno itemname 2 Pocket knife - Avon If you are interested in learning the inner workings of the preceding SQL for divide, see the additional material for Chapter 5 on the book’s Web site. Relational algebra (Chapter 9) has the divide operation, which makes divide queries easy to write. Be careful: Not all queries containing the word all are divides. With experience, you will learn to recognize and conquer divide. To save the tedium of formulating this query from scratch, we have developed a template for dealing with these sorts of queries. Divide queries typically occur with m:m relationships. A template for divide An appropriate generic query and template SQL command are Find the target1 that have appeared in all sources. SELECT target1 FROM target WHERE NOT EXISTS (SELECT * FROM source WHERE NOT EXISTS (SELECT * FROM target-source WHERE target-source.target# = target.target# AND target-source.source# = source.source#)); ❓ Skill builder Find the brown items that have appeared in all sales. Beyond the great divide Divide proves troublesome to most people because of the double negative—we just don’t think that way. If divide sends your neurons into knots, then try the following approach. The query “Find the items that have appeared in all sales” can be rephrased as “Find the items for which the number of sales that include this item is equal to the total number of sales.” This is an easier query to write than “Find items such that there does not exist a sale in which this item does not appear.” The rephrased query has two parts. First, determine the total number of sales. Here we mean distinct sales (i.e., the number of rows with a distinct value for saleno). The SQL is SELECT COUNT (DISTINCT saleno) FROM sale; Second, group the items sold by itemno and itemname and use a HAVING clause with COUNT to calculate the number of sales in which the item has occurred. Forcing the count in the HAVING clause to equal the result of the first query, which becomes an inner query, results in a list of items appearing in all sales. SELECT item.itemno, item.itemname FROM item JOIN lineitem ON item.itemno = lineitem.itemno GROUP BY item.itemno, item.itemname HAVING COUNT(DISTINCT saleno) = (SELECT COUNT(DISTINCT saleno) FROM sale); Set operations Set operators are useful for combining the values derived from two or more SQL queries. The UNION operation is equivalent to or, and INTERSECT is equivalent to and. List items that were sold on January 16, 2011, or are brown. Resolution of this query requires two tables: one to report items sold on January 16, 2011, and one to report the brown items. UNION (i.e., or) then combines the results of the tables, including any rows in both tables and excluding duplicate rows. SELECT itemname FROM item JOIN lineitem ON item.itemno = lineitem.itemno JOIN sale ON lineitem.saleno = sale.saleno WHERE saledate = &#39;2011-01-16&#39; UNION SELECT itemname FROM item WHERE itemcolor = &#39;Brown&#39;; Table 4.5: 8 records itemname Safari chair Hammock Tent - 8 person Tent - 2 person Pocket knife - Avon Pocket knife - Nile Map case Stetson List items that were sold on January 16, 2011, and are brown. This query uses the same two tables as the previous query. In this case, INTERSECT (i.e., and) then combines the results of the tables including only rows in both tables and excluding duplicates.12 SELECT itemname FROM item JOIN lineitem ON item.itemno = lineitem.itemno JOIN sale ON lineitem.saleno = sale.saleno WHERE saledate = &#39;2011-01-16&#39; INTERSECT SELECT itemname FROM item WHERE itemcolor = &#39;Brown&#39;; ❓ Skill builder List the items that contain the words “Hat”, “Helmet”, or “Stetson” in their names Summary There can be a many-to-many (m:m) relationship between entities, which is represented by creating an associative entity and two 1:m relationships. An associative entity stores data about an m:m relationship. The join operation can be extended from two tables to three or more tables. EXISTS tests whether a table has at least one row that meets a specified condition. NOT EXISTS tests whether all rows in a table do not satisfy a specified condition. Both EXISTS and NOT EXISTS can return true or false. The relational operation divide, also known as forall, can be translated into a double negative. It is represented in SQL by a query containing two NOT EXISTS statements. Set operations enable the results of queries to be combined. Key terms and concepts Associative entity Many-to-many (m:m) relationship Divide NOT EXISTS Existential quantifier UNION EXISTS Universal quantifier INTERSECT Exercises Draw data models for the following situations. In each case, think about the names you give each entity: Farmers can own cows or share cows with other farmers. A track and field meet can have many competitors, and a competitor can participate in more than one event. A patient can have many physicians, and a physician can have many patients. A student can attend more than one class, and the same class can have many students. The Marathoner, a monthly magazine, regularly reports the performance of professional marathon runners. It has asked you to design a database to record the details of all major marathons (e.g., Boston, London, and Paris). Professional marathon runners compete in several races each year. A race may have thousands of competitors, but only about 200 or so are professional runners, the ones The Marathoner tracks. For each race, the magazine reports a runner’s time and finishing position and some personal details such as name, gender, and age. The data model shown was designed by a golf statistician. Write SQL statements to create the corresponding relational database. Write the following SQL queries for the database described in this chapter: List the names of items for which the quantity sold is greater than one for any sale. Compute the total value of sales for each item by date. Report all items of type “F” that have been sold. List all items of type “F” that have not been sold. Compute the total value of each sale. Why do you have to create a third entity when you have an m:m relationship? What does a plus sign near a relationship arc mean? How does EXISTS differ from other clauses in an SQL statement? Answer the following queries based on the described relational database. List the phone numbers of donors Hays and Jefts. How many donors are there in the donor table? How many people made donations in 1999? What is the name of the person who made the largest donation in 1999? What was the total amount donated in 2000? List the donors who have made a donation every year. List the donors whose average donation is more than twice the average donation of all donors. List the total amount given by each person across all years; sort the report by the donor’s name. Report the total donations in 2001 by state. In which years did the total donated exceed the goal for the year? The following table records data found on the side of a breakfast cereal carton. Use these data as a guide to develop a data model to record nutrition facts for a meal. In this case, a meal is a cup of cereal and 1/2 cup of skim milk. Nutrition facts Serving size 1 cup (30g) Servings per container about 17 Amount per serving Cereal with 1/2 cup of skim milk Calories 110 150 Calories from Fat 10 10 % Daily Value Total Fat 1g 1% 2% Saturated Fat 0g 0% 0% Polyunsaturated Fat 0g Monounsaturated Fat 0g Cholesterol 0mg 0% 1% Sodium 220mg 9% 12% Potassium 105 mg 3% 9% Total Carbohydrate 24g 8% 10% Dietary Fiber 3g 13% 13% Sugars 4g Other Carbohydrate 17g Protein 3g Vitamin A 10% 15% Vitamin C 10% 10% Calcium 2% 15% Iron 45% 45% Vitamin D 10% 25% Thiamin 50% 50% Riboflavin 50% 50% Niacin 50% 50% Vitamin B12 50% 60% Phosphorus 10% 20% Magnesium 8% 10% Zinc 50% 50% Copper 4% 4% “Two women share a name, birthday, and S.S. number!” Athens Daily News, January 29 1990, 7A. Also, see https://www.computerworld.com/article/3004659/a-tale-of-two-women-same-birthday-same-social-security-number-same-big-data-mess.html↩︎ MySQL does not support INTERSECT. Use another AND in the WHERE statement.↩︎ "],["sql.html", "Chapter 5 SQL Structured query language Creating a table Data types Collation sequence Scalar functions Formatting Table commands Data manipulation INSERT UPDATE DELETE SQL routines Universal Unique Identifier (UUID) Nulls—much ado about missing information Security The system catalog Natural language processing Connectivity and ODBC Embedded SQL User-defined types The future of SQL", " Chapter 5 SQL The questing beast. Sir Thomas Malory, Le Morte D’Arthur, 1470 Learning objectives Students completing this chapter will have a detailed knowledge of SQL. Structured query language Structured query language (SQL) is widely used as a relational database language, and SQL skills are essential for data management in a world that is increasingly reliant on database technology. SQL originated in the IBM Research Laboratory in San Jose, California. Versions have since been implemented by commercial database vendors and open source teams for a wide range of operating systems. Both the American National Standards Institute (ANSI) and the International Organization for Standardization (ISO) have designated SQL as a standard language for relational database systems. SQL is a complete database language. It is used for defining a relational database, creating views, and specifying queries. In addition, it allows for rows to be inserted, updated, and deleted. In database terminology, it is both a data definition language (DDL), a data manipulation language (DML), and a data control language (DCL). SQL, however, is not a complete programming language like Python, R, and Java. Because SQL statements can be embedded into general-purpose programming languages, SQL is often used in conjunction with such languages to create application programs. The embedded SQL statements handle the database processing, and the statements in the general-purpose language perform the necessary tasks to complete the application. SQL is a declarative language, because you declare the desired results. Languages such as Java are procedural languages, because the programmer specifies each step the computer must execute. The SQL programmer can focus on defining what is required rather than detailing the process to achieve what is required. Thus, SQL programs are much shorter than their procedural equivalents. You were introduced to SQL in Chapters 3 through 6. This chapter provides an integrated coverage of the language, pulling together the various pieces presented previously. Data definition The DDL part of SQL encompasses statements to operate on tables, views, and indexes. Before we proceed, however, the term “base table” must be defined. A base table is an autonomous, named table. It is autonomous because it exists in its own right; it is physically stored within the database. In contrast, a view is not autonomous because it is derived from one or more base tables and does not exist independently. A view is a virtual table. A base table has a name by which it can be referenced. This name is chosen when the base table is generated using the CREATE statement. Short-lived temporary tables, such as those formed as the result of a query, are not named. Key The concept of a key occurs several times within SQL. In general, a key is one or more columns identified as such in the description of a table, an index, or a referential constraint. The same column can be part of more than one key. For example, it can be part of a primary key and a foreign key. A composite key is an ordered set of columns of the same table. In other words, the primary key of lineitem is always the composite of (lineno, saleno) in that order, which cannot be changed. Comparing composite keys actually means that corresponding components of the keys are compared. Thus, application of the referential integrity rule—the value of a foreign key must be equal to a value of the primary key —means that each component of the foreign key must be equal to the corresponding component of the composite primary key. So far, you have met primary and foreign keys. A unique key is another type of key. Its purpose is to ensure that no two values of a given column are equal. This constraint is enforced by the RDBMS during the execution of INSERT and UPDATE statements. A unique key is part of the index mechanism. Index Indexes are used to accelerate data access and ensure uniqueness. An index is an ordered set of pointers to rows of a base table. Think of an index as a table that contains two columns. The first column contains values for the index key, and the second contains a list of addresses of rows in the table. Since the values in the first column are ordered (i.e., in ascending or descending sequence), the index table can be searched quickly. Once the required key has been found in the table, the row’s address in the second column can be used to retrieve the data quickly. An index can be specified as being unique, in which case the RDBMS ensures that the corresponding table does not have rows with identical index keys. An example of an index Notation A short primer on notation is required before we examine SQL commands. Text in uppercase is required as is. Text in lowercase denotes values to be selected by the query writer. Statements enclosed within square brackets are optional. | indicates a choice. An ellipsis ... indicates that the immediate syntactic unit may be repeated optionally more than once. Creating a table CREATE TABLE is used to define a new base table, either interactively or by embedding the statement in a host language. The statement specifies a table’s name, provides details of its columns, and provides integrity checks. The syntax of the command is CREATE TABLE base-table column-definition-block [primary-key-block] [referential-constraint-block] [unique-block]; Column definition The column definition block defines the columns in a table. Each column definition consists of a column name, data type, and optionally the specification that the column cannot contain null values. The general form is (column-definition [, ...]) where column-definition is of the form column-name data-type [NOT NULL] The NOT NULL clause specifies that the particular column must have a value whenever a new row is inserted. Constraints A constraint is a rule defined as part of CREATE TABLE that defines valid sets of values for a base table by placing limits on INSERT, UPDATE, and DELETE operations. Constraints can be named (e.g., fk_stock_nation) so that they can be turned on or off and modified. The four constraint variations apply to primary key, foreign key, unique values, and range checks. Primary key constraint The primary key constraint block specifies a set of columns that constitute the primary key. Once a primary key is defined, the system enforces its uniqueness by checking that the primary key of any new row does not already exist in the table. A table can have only one primary key. While it is not mandatory to define a primary key, it is good practice always to define a table’s primary key, though it is not that common to name the constraint. The general form of the constraint is [primary-key-name] PRIMARY KEY(column-name [asc|desc] [, ...]) The optional ASC or DESC clause specifies whether the values from this key are arranged in ascending or descending order, respectively. For example: pk_stock PRIMARY KEY(stkcode) Foreign key constraint The referential constraint block defines a foreign key, which consists of one or more columns in the table that together must match a primary key of the specified table (or else be null). A foreign key value is null when any one of the columns in the row constituting the foreign key is null. Once the foreign key constraint is defined, the RDBMS will check every insert and update to ensure that the constraint is observed. The general form is CONSTRAINT constraint-name FOREIGN KEY(column-name [,…]) REFERENCES table-name(column-name [,…]) [ON DELETE (RESTRICT | CASCADE | SET NULL)] The constraint-name defines a referential constraint. You cannot use the same constraint-name more than once in the same table. Column-name identifies the column or columns that comprise the foreign key. The data type and length of foreign key columns must match exactly the data type and length of the primary key columns. The clause REFERENCES table-name specifies the name of an existing table, and its primary key, that contains the primary key, which cannot be the name of the table being created. The ON DELETE clause defines the action taken when a row is deleted from the table containing the primary key. There are three options: RESTRICT prevents deletion of the primary key row until all corresponding rows in the related table, the one containing the foreign key, have been deleted. RESTRICT is the default and the cautious approach for preserving data integrity. CASCADE causes all the corresponding rows in the related table also to be deleted. SET NULLS sets the foreign key to null for all corresponding rows in the related table. For example: CONSTRAINT fk_stock_nation FOREIGN KEY(natcode) REFERENCES nation(natcode) Unique constraint A unique constraint creates a unique index for the specified column or columns. A unique key is constrained so that no two of its values are equal. Columns appearing in a unique constraint must be defined as NOT NULL. Also, these columns should not be the same as those of the table’s primary key, which is guaranteed uniqueness by its primary key definition. The constraint is enforced by the RDBMS during execution of INSERT and UPDATE statements. The general format is UNIQUE constraint-name (column-name [ASC|DESC] [, …]) An example follows: CONSTRAINT unq_stock_stkname UNIQUE(stkname) Check constraint A check constraint defines a set of valid values and can be set for a table or column. Table constraints are defined in CREATE TABLE and ALTER TABLE statements. They can be set for one or more columns in a table. A table constraint, for example, might ensure that the selling prices is greater than the cost. CREATE TABLE item ( costPrice DECIMAL(9,2), sellPrice DECIMAL(9,2), CONSTRAINT profit_check CHECK (sellPrice &gt; costPrice)); A column constraint is defined in a CREATE TABLE statement for a single column. In the following case, category is restricted to three values. CREATE TABLE item ( category CHAR(1) CONSTRAINT category_constraint CHECK (category IN (&#39;B&#39;, &#39;L&#39;, &#39;S&#39;))); Data types Some of the variety of data types that can be used are depicted in the following figure and described in more detail in the following pages. Data types BOOLEAN Boolean data types can have the values true, false, or unknown. SMALLINT and INTEGER Most commercial computers have a 32-bit word, where a word is a unit of storage. An integer can be stored in a full word or half a word. If it is stored in a full word (INTEGER), then it can be 31 binary digits in length. If half-word storage is used (SMALLINT), then it can be 15 binary digits long. In each case, one bit is used for the sign of the number. A column defined as INTEGER can store a number in the range -231 to 231-1 or -2,147,483,648 to 2,147,483,647. A column defined as SMALLINT can store a number in the range -215 to 215-1 or -32,768 to 32,767. Just remember that INTEGER is good for ±2 billion and SMALLINT for ±32,000. FLOAT Scientists often deal with numbers that are very large (e.g., Avogadro’s number is 6.02252×1023) or very small (e.g., Planck’s constant is 6.6262×10-34 joule sec). The FLOAT data type is used for storing such numbers, often referred to as floating-point numbers. A single-precision floating-point number requires 32 bits and can represent numbers in the range -7.2×1075 to -5.4×10-79, 0, 5.4×10-79 to 7.2×1075 with a precision of about 7 decimal digits. A double-precision floating-point number requires 64 bits. The range is the same as for a single-precision floating-point number. The extra 32 bits are used to increase precision to about 15 decimal digits. In the specification FLOAT(n), if n is between 1 and 21 inclusive, single-precision floating-point is selected. If n is between 22 and 53 inclusive, the storage format is double-precision floating-point. If n is not specified, double-precision floating-point is assumed. DECIMAL Binary is the most convenient form of storing data from a computer’s perspective. People, however, work with a decimal number system. The DECIMAL data type is convenient for business applications because data storage requirements are defined in terms of the maximum number of places to the left and right of the decimal point. To store the current value of an ounce of gold, you would possibly use DECIMAL(6,2) because this would permit a maximum value of $9,999.99. Notice that the general form is DECIMAL(p,q), where p is the total number of digits in the column, and q is the number of digits to the right of the decimal point. CHAR and VARCHAR Nonnumeric columns are stored as character strings. A person’s family name is an example of a column that is stored as a character string. CHAR(n) defines a column that has a fixed length of n characters, where n can be a maximum of 255. When a column’s length can vary greatly, it makes sense to define the field as VARCHAR. A column defined as VARCHAR consists of two parts: a header indicating the length of the character string and the string. If a table contains a column that occasionally stores a long string of text (e.g., a message field), then defining it as VARCHAR makes sense. VARCHAR can store strings up to 65,535 characters long. Why not store all character columns as VARCHAR and save space? There is a price for using VARCHAR with some relational systems. First, additional space is required for the header to indicate the length of the string. Second, additional processing time is required to handle a variable-length string compared to a fixed-length string. Depending on the RDBMS and processor speed, these might be important considerations, and some systems will automatically make an appropriate choice. For example, if you use both data types in the same table, MySQL will automatically change CHAR into VARCHAR for compatibility reasons. There are some columns where there is no trade-off because all possible entries are always the same length. Canadian postal codes, for instance, are always six characters (e.g., the postal code for Ottawa is K1A0A1). Data compression is another approach to the space wars problem. A database can be defined with generous allowances for fixed-length character columns so that few values are truncated. Data compression can be used to compress the file to remove wasted space. Data compression, however, is slow and will increase the time to process queries. You save space at the cost of time, and save time at the cost of space. When dealing with character fields, the database designer has to decide whether time or space is more important. Times and dates Columns that have a data type of DATE are stored as yyyymmdd (e.g., 2022-11-04 for November 4, 2022). There are two reasons for this format. First, it is convenient for sorting in chronological order. The common American way of writing dates (mmddyy) requires processing before chronological sorting. Second, the full form of the year should be recorded for exactness. For similar reasons, it makes sense to store times in the form hhmmss with the understanding that this is 24-hour time (also known as European time and military time). This is the format used for data type TIME. Some applications require precise recording of events. For example, transaction processing systems typically record the time a transaction was processed by the system. Because computers operate at high speed, the TIMESTAMP data type records date and time with microsecond accuracy. A timestamp has seven parts: year, month, day, hour, minute, second, and microsecond. Date and time are defined as previously described (i.e., yyyymmdd and hhmmss, respectively). The range of the microsecond part is 000000 to 999999. Although times and dates are stored in a particular format, the formatting facilities that generally come with a RDBMS usually allow tailoring of time and date output to suit local standards. Thus for a U.S. firm, date might appear on a report in the form mm/dd/yy; for a European firm following the ISO standard, date would appear as yyyy-mm-dd. SQL-99 introduced the INTERVAL data type, which is a single value expressed in some unit or units of time (e.g., 6 years, 5 days, 7 hours). BLOB (binary large object) BLOB is a large-object data type that stores any kind of binary data. Binary data typically consists of a saved spreadsheet, graph, audio file, satellite image, voice pattern, or any digitized data. The BLOB data type has no maximum size. CLOB (character large object) CLOB is a large-object data type that stores any kind of character data. Text data typically consists of reports, correspondence, chapters of a manual, or contracts. The CLOB data type has no maximum size. ❓ Skill builder What data types would you recommend for the following? A book’s ISBN A photo of a product The speed of light (2.9979 × 108 meters per second) A short description of an animal’s habitat The title of a Japanese book A legal contract The status of an electrical switch The date and time a reservation was made An item’s value in euros The number of children in a family Collation sequence A RDBMS will typically support many character sets. so it can handle text in different languages. While many European languages are based on an alphabet, they do not all use the same alphabet. For example, Norwegian has some additional characters (e.g., æ ,ø, å) compared to English, and French accents some letters (e.g., é, ü, and ȃ), which do not occur in English. Alphabet based languages have a collating sequence, which defines how to sort individual characters in a particular language. For English, it is the familiar A B C … X Y Z. Norwegian’s collating sequence includes three additional symbols, and the sequence is A B C … X Y Z Æ Ø Å. When you define a database you need to define its collating sequence. Thus, a database being set up for exclusive use in Chile would opt for a Spanish collating sequence. You can specify a collation sequence at the database, table, and, column level. The usual practice is to specify at the database level. CREATE DATABASE ClassicModels COLLATE latin1_general_cs; The latin1_general character set is suitable for Western European languages. The cs suffix indicates that comparisons are case sensitive. In other words, a query will see the two strings ‘abc’ and ‘Abc’ as different, whereas if case sensitivity is turned off, the strings are considered identical. Case sensitivity is usually the right choice to ensure precision of querying. Scalar functions Most implementations of SQL include functions that can be used in arithmetic expressions, and for data conversion or data extraction. The following sampling of these functions will give you an idea of what is available. You will need to consult the documentation for your version of SQL to determine the functions it supports. For example, Microsoft SQL Server has more than 100 additional functions. Some examples of SQL’s built-in scalar functions Function Description CURRENT_DATE() Retrieves the current date EXTRACT(date_time_part FROM expression) Retrieves part of a time or date (e.g., YEAR, MONTH, DAY, HOUR, MINUTE, or SECOND) SUBSTRING(str, pos, len) Retrieves a string of length len starting at position pos from string str Some examples for you to run SELECT extract(day) FROM CURRENT_DATE()); SELECT SUBSTRING(`person first`, 1,1), `person last` FROM person; A vendor’s additional functions can be very useful. Remember, though, that use of a vendor’s extensions might limit portability. How many days’ sales are stored in the sale table? This sounds like a simple query, but you have to do a self-join and also know that there is a function, DATEDIFF, to determine the number of days between any two dates. Consult your RDBMS manual to learn about other functions for dealing with dates and times. WITH late AS (SELECT * FROM sale), early AS (SELECT * FROM sale) SELECT DISTINCT DATEDIFF(late.saledate,early.saledate) AS Difference FROM late JOIN early ON late.saledate = (SELECT MAX(saledate) FROM sale) AND early.saledate = (SELECT MIN(saledate) FROM sale); The preceding query is based on the idea of joining sale with a copy of itself. The matching column from late is the latest sale’s date (or MAX), and the matching column from early is the earliest sale’s date (or MIN). As a result of the join, each row of the new table has both the earliest and latest dates. Formatting You will likely have noticed that some queries report numeric values with a varying number of decimal places. The FORMAT function gives you control over the number of decimal places reported, as illustrated in the following example where yield is reported with two decimal places. SELECT shrfirm, shrprice, shrqty, FORMAT(shrdiv/shrprice*100,2) AS yield FROM share; When you use format you create a string, but you often want to sort on the numeric value of the formatted field. The following example illustrates how to do this. SELECT shrfirm, shrprice, shrqty, FORMAT(shrdiv/shrprice*100,2) AS yield FROM share ORDER BY shrdiv/shrprice*100 DESC; Run the following code to see the difference. SELECT shrfirm, shrprice, shrqty, FORMAT(shrdiv/shrprice*100,2) AS yield FROM share ORDER BY yield DESC; Table commands Altering a table The ALTER TABLE statement has two purposes. First, it can add a single column to an existing table. Second, it can add, drop, activate, or deactivate primary and foreign key constraints. A base table can be altered by adding one new column, which appears to the right of existing columns. The format of the command is ALTER TABLE base-table ADD column data-type; Notice that there is no optional NOT NULL clause for column-definition with ALTER TABLE. It is not allowed because the ALTER TABLE statement automatically fills the additional column with null in every case. If you want to add multiple columns, you repeat the command. ALTER TABLE does not permit changing the width of a column or amending a column’s data type. It can be used for deleting an unwanted column. ALTER TABLE stock ADD stkrating CHAR(3); ALTER TABLE is also used to change the status of referential constraints. You can deactivate constraints on a table’s primary key or any of its foreign keys. Deactivation also makes the relevant tables unavailable to everyone except the table’s owner or someone possessing database management authority. After the data are loaded, referential constraints must be reactivated before they can be automatically enforced again. Activating the constraints enables the RDBMS to validate the references in the data. Dropping a table A base table can be deleted at any time by using the DROP statement. The format is DROP TABLE base-table; The table is deleted, and any views or indexes defined on the table are also deleted. Creating a view A view is a virtual table. It has no physical counterpart but appears to the client as if it really exists. A view is defined in terms of other tables that exist in the database. The syntax is CREATE VIEW view [column [,column] …)] AS subquery; There are several reasons for creating a view. First, a view can be used to restrict access to certain rows or columns. This is particularly important for sensitive data. An organization’s person table can contain both private data (e.g., annual salary) and public data (e.g., office phone number). A view consisting of public data (e.g., person’s name, department, and office telephone number) might be provided to many people. Access to all columns in the table, however, might be confined to a small number of people. Here is a sample view that restricts access to a table. CREATE VIEW stklist AS SELECT stkfirm, stkprice FROM stock; Handling derived data is a second reason for creating a view. A column that can be computed from one or more other columns should always be defined by a view. Thus, a stock’s yield would be computed by a view rather than defined as a column in a base table. CREATE VIEW stk (stkfirm, stkprice, stkqty, stkyield) AS SELECT stkfirm, stkprice, stkqty, stkdiv/stkprice*100 FROM stock; A third reason for defining a view is to avoid writing common SQL queries. For example, there may be some joins that are frequently part of an SQL query. Productivity can be increased by defining these joins as views. Here is an example: CREATE VIEW stkvalue (nation, firm, price, qty, value) AS SELECT natname, stkfirm, stkprice*exchrate, stkqty, stkprice*exchrate*stkqty FROM stock JOIN nation ON stock.natcode = nation.natcode; The preceding example demonstrates how CREATE VIEW can be used to rename columns, create new columns, and involve more than one table. The column nation corresponds to natname, firm to stkfirm, and so forth. A new column, price, is created that converts all share prices from the local currency to British pounds. Data conversion is a fourth useful reason for a view. The United States is one of the few countries that does not use the metric system, and reports for American managers often display weights and measures in pounds and feet, respectively. The database of an international company could record all measurements in metric format (e.g., weight in kilograms) and use a view to convert these measures for American reports. When a CREATE VIEW statement is executed, the definition of the view is entered in the systems catalog. The subquery following AS, the view definition, is executed only when the view is referenced in an SQL command. For example, the following command would enable the subquery to be executed and the view created: SELECT * FROM stkvalue WHERE price &gt; 10; SELECT natname, stkfirm, stkprice*exchrate, stkqty, stkprice*exchrate*stkqty FROM stock JOIN nation ON stock.natcode = nation.natcode WHERE stkprice*exchrate &gt; 10; Any table that can be defined with a SELECT statement is a potential view. Thus, it is possible to have a view that is defined by another view. Dropping a view DROP VIEW is used to delete a view from the system catalog. A view might be dropped because it needs to be redefined or is no longer used. It must be dropped before a revised version of the view is created. The syntax is DROP VIEW view; Remember, if a base table is dropped, all views based on that table are also dropped. Creating an index An index helps speed up retrieval (a more detailed discussion of indexing is covered later in this book). A column that is frequently referred to in a WHERE clause is a possible candidate for indexing. For example, if data on stocks were frequently retrieved using stkfirm, then this column should be considered for an index. The format for CREATE INDEX is CREATE [UNIQUE] INDEX indexname ON base-table (column [order] [,column, [order]] …) [CLUSTER]; This next example illustrates use of CREATE INDEX. CREATE UNIQUE INDEX stkfirmindx ON stock(stkfirm); In the preceding example, an index called stkfirmindx is created for the table stock. Index entries are ordered by ascending (the default order) values of stkfirm. The optional clause UNIQUE specifies that no two rows in the base table can have the same value for stkfirm, the indexed column. Specifying UNIQUE means that the RDBMS will reject any insert or update operation that would create a duplicate value for stkfirm. A composite index can be created from several columns, which is often necessary for an associative entity. The following example illustrates the creation of a composite index. CREATE INDEX lineitemindx ON lineitem (lineno, saleno); Dropping an index Indexes can be dropped at any time by using the DROP INDEX statement. The general form of this statement is DROP INDEX index; Data manipulation SQL supports four DML statements—SELECT, INSERT, UPDATE, and DELETE. Each of these is discussed in turn, with most attention focusing on SELECT because of the variety of ways in which it can be used. First, we need to understand why we must qualify column names and temporary names. Qualifying column names Ambiguous references to column names are avoided by qualifying a column name with its table name, especially when the same column name is used in several tables. Clarity is maintained by prefixing the column name with the table name. The following example demonstrates qualification of the natcode, which appears in both stock and nation. SELECT stkfirm, stkprice FROM stock JOIN nation ON stock.natcode = nation.natcode; Temporary names Using the WITH clause, a table or view can be given a temporary name, or alias, that remains current for a query. Temporary names are used in a self-join to distinguish the copies of the table. WITH wrk AS (SELECT * FROM emp), boss AS (SELECT * FROM emp) SELECT wrk.empfname FROM wrk JOIN boss ON wrk.bossno = boss.empno; A temporary name also can be used as a shortened form of a long table name. For example, l might be used merely to avoid having to enter lineitem more than once. If a temporary name is specified for a table or view, any qualified reference to a column of the table or view must also use that temporary name. SELECT The SELECT statement is by far the most interesting and challenging of the four DML statements. It reveals a major benefit of the relational model: powerful interrogation capabilities. It is challenging because mastering the power of SELECT requires considerable practice with a wide range of queries. The major varieties of SELECT are presented in this section. The SQL Playbook, on the book’s website, reveals the full power of the command. The general format of SELECT is SELECT [DISTINCT] item(s) FROM table(s) [WHERE condition] [GROUP BY column(s)] [HAVING condition] [ORDER BY column(s)]; Alternatively, we can diagram the structure of SELECT. Structure of SELECT Product Product, or more strictly Cartesian product, is a fundamental operation of relational algebra. It is rarely used by itself in a query; however, understanding its effect helps in comprehending join. The product of two tables is a new table consisting of all rows of the first table concatenated with all possible rows of the second table. For example: Form the product of stock and nation. SELECT * FROM stock, nation; Run the query and observe that the new table contains 64 rows (16*4), where stock has 16 rows and nation has 4 rows. It has 10 columns (7 + 3), where stock has 7 columns and nation has 3 columns. Note that each row in stock is concatenated with each row in nation. Find the percentage of Australian stocks in the portfolio. To answer this query, you need to count the number of Australian stocks, count the total number of stocks in the portfolio, and then compute the percentage. Computing each of the totals is a straightforward application of COUNT. If we save the results of the two counts as views, then we have the necessary data to compute the percentage. The two views each consist of a single-cell table (i.e., one row and one column). We create the product of these two views to get the data needed for computing the percentage in one row. The SQL is CREATE VIEW austotal (auscount) AS SELECT COUNT(*) FROM nation JOIN stock ON natname = &#39;Australia&#39; WHERE nation.natcode = stock.natcode; CREATE VIEW total (totalcount) AS SELECT COUNT(*) FROM stock; SELECT auscount/totalcount*100 AS percentage FROM austotal, total; CREATE VIEW total (totalcount) AS SELECT COUNT(*) FROM stock; SELECT auscount*100/totalcount as Percentage FROM austotal, total; The result of a COUNT is always an integer, and SQL will typically create an integer data type in which to store the results. When two variables have a data type of integer, SQL will likely use integer arithmetic for all computations, and all results will be integer. To get around the issue of integer arithmetic, we first multiply the number of Australian stocks by 100 before dividing by the total number of stocks. Because of integer arithmetic, you might get a different answer if you use the following SQL. SELECT auscount/totalcount*100 as Percentage FROM austotal, total; The preceding example was used to show when you might find product useful. You can also write the query as SELECT (SELECT COUNT(*) FROM stock WHERE natcode = &#39;AUS&#39;)*100/ (SELECT COUNT(*) FROM stock) as Percentage; Inner join Inner join, often referred to as join, is a powerful and frequently used operation. It creates a new table from two existing tables by matching on a column common to both tables. An equijoin is the simplest form of join; in this case, columns are matched on equality. SELECT * FROM stock JOIN nation ON stock.natcode = nation.natcode; There are other ways of expressing join that are more concise. For example, we can write SELECT * FROM stock INNER JOIN nation USING (natcode); The preceding syntax implicitly recognizes the frequent use of the same column name for matching primary and foreign keys. A further simplification is to rely on the primary and foreign key definitions to determine the join condition, so we can write SELECT * FROM stock NATURAL JOIN nation; An equijoin creates a new table that contains two identical columns. If one of these is dropped, then the remaining table is called a natural join. As you now realize, join can be thought of as a product with a condition clause. There is no reason why this condition needs to be restricted to equality. There could easily be another comparison operator between the two columns. This general version is called a theta-join because theta is a variable that can take any value from the set ‘=’, ‘&lt;’, ‘&lt;=’, ‘&gt;’, and ‘&gt;=’. As you discovered earlier, there are occasions when you need to join a table to itself. To do this, make two copies of the table and give each of them a unique name. Find the names of employees who earn more than their boss. SELECT wrk.empfname FROM emp wrk JOIN emp boss ON wrk.bossno = boss.empno WHERE wrk.empsalary &gt; boss.empsalary; Outer join An inner join reports those rows where the primary and foreign keys match. There are also situations where you might want an outer join, which comes in three flavors as shown in the following figure. Types of joins A traditional join, more formally known as an inner join, reports those rows where the primary and foreign keys match. An outer join reports these matching rows and other rows depending on which form is used, as the following examples illustrate for the sample table. t1 t2 id col1 id col2 1 a 1 x 2 b 3 y 3 c 5 z A left outer join is an inner join plus those rows from t1 not included in the inner join. SELECT id, col1, col2 FROM t1 LEFT JOIN t2 USING (id) id col1 col2 1 a x 2 b null 3 c y Here is an example to illustrate the use of a left join. For all brown items, report each sale. Include in the report those brown items that have appeared in no sales. SELECT itemname, saleno, lineqty FROM item LEFT JOIN lineitem USING (itemno) WHERE itemcolor = &#39;Brown&#39; ORDER BY itemname; A right outer join is an inner join plus those rows from t2 not included in the inner join. SELECT id, col1, col2 FROM t1 RIGHT JOIN t2 USING (id); Id col1 col2 1 a x 3 c y 5 null z A full outer join is an inner join plus those rows from t1 and t2 not included in the inner join. SELECT id, col1, col2 FROM t1 FULL JOIN t2 USING (id); id col1 col2 1 a x 2 b null 3 c y 5 null z MySQL does not support a full outer join, rather you must use a union of left and right outer joins. SELECT id, col1, col2 FROM t1 LEFT JOIN t2 USING (id) UNION SELECT id, col1, col2 FROM t1 RIGHT JOIN t2 USING (id); Simple subquery A subquery is a query within a query. There is a SELECT statement nested inside another SELECT statement. Simple subqueries were used extensively in earlier chapters. For reference, here is a simple subquery used earlier: SELECT stkfirm FROM stock WHERE natcode IN (SELECT natcode FROM nation WHERE natname = &#39;Australia&#39;); Correlated subquery A correlated subquery differs from a simple subquery in that the inner query must be evaluated more than once. Consider the following example described previously: Find those stocks where the quantity is greater than the average for that country. SELECT natname, stkfirm, stkqty FROM stock JOIN nation ON stock.natcode = nation.natcode WHERE stkqty &gt; (SELECT AVG(stkqty) FROM stock WHERE stock.natcode = nation.natcode); The requirement to compare a column against a function (e.g., average or count) of some column of specified rows of is usually a clue that you need to write a correlated subquery. In the preceding example, the stock quantity for each row is compared with the average stock quantity for that row’s country. Aggregate functions SQL’s aggregate functions increase its retrieval power. These functions were covered earlier and are only mentioned briefly here for completeness. The five aggregate functions are shown in the following table. Nulls in the column are ignored in the case of SUM, AVG, MAX, and MIN. COUNT(*) does not distinguish between null and non-null values in a column. Use COUNT(columnname) to exclude a null value in columnname. Aggregate functions Function Description COUNT Counts the number of values in a column SUM Sums the values in a column AVG Determines the average of the values in a column MAX Determines the largest value in a column MIN Determines the smallest value in a column GROUP BY and HAVING The GROUP BY clause is an elementary form of control break reporting and supports grouping of rows that have the same value for a specified column and produces one row for each different value of the grouping column. For example, Report by nation the total value of stockholdings. SELECT natname, SUM(stkprice*stkqty*exchrate) AS total FROM stock JOIN nation ON stock.natcode = nation.natcode GROUP BY natname; The HAVING clause is often associated with GROUP BY. It can be thought of as the WHERE clause of GROUP BY because it is used to eliminate rows for a GROUP BY condition. Both GROUP BY and HAVING are dealt with in-depth in Chapter 4. REGEXP The REGEXP clause supports pattern matching to find a defined set of strings in a character column (CHAR or VARCHAR). Refer to Chapters 3 and 4 for more details. 5.0.1 CASE The CASE statement is used to implement a series of conditional clauses. In the following query, the first step creates a temporary table that records customers and their total orders. The second step classifies customers into four categories based on their total orders. WITH temp AS (SELECT customerName, COUNT(*) AS orderCount FROM Orders JOIN Customers ON Customers.customerNumber = Orders.customerNumber GROUP BY customerName) SELECT customerName, orderCount, CASE orderCount WHEN 1 THEN &#39;One-time Customer&#39; WHEN 2 THEN &#39;Repeated Customer&#39; WHEN 3 THEN &#39;Frequent Customer&#39; ELSE &#39;Loyal Customer&#39; end customerType FROM temp ORDER BY customerName; INSERT There are two formats for INSERT. The first format is used to insert one row into a table. Inserting a single record The general form is INSERT INTO table [(column [,column] …)] VALUES (literal [,literal] …); For example, INSERT INTO stock (stkcode,stkfirm,stkprice,stkqty,stkdiv,stkpe) VALUES (&#39;FC&#39;,&#39;Freedonia Copper&#39;,27.5,10529,1.84,16); In this example, stkcode is given the value “FC,” stkfirm is “Freedonia Copper,” and so on. The nth column in the table is the nth value in the list. When the value list refers to all field names in the left-to-right order in which they appear in the table, then the columns list can be omitted. So, it is possible to write the following: INSERT INTO stock VALUES (&#39;FC&#39;,&#39;Freedonia Copper&#39;,27.5,10529,1.84,16); If some values are unknown, then the INSERT can omit these from the list. Undefined columns will have nulls. For example, if a new stock is to be added for which the PE ratio is 5, the following INSERT statement would be used: INSERT INTO stock (stkcode, stkfirm, stkPE) VALUES (&#39;EE&#39;,&#39;Elysian Emeralds&#39;,5); Inserting multiple records using a query The second form of INSERT operates in conjunction with a subquery. The resulting rows are then inserted into a table. Imagine the situation where stock price information is downloaded from an information service into a table. This table could contain information about all stocks and may contain additional columns that are not required for the stock table. The following INSERT statement could be used: INSERT INTO stock (stkcode, stkfirm, stkprice, stkdiv, stkpe) SELECT code, firm, price, div, pe FROM download WHERE code IN (&#39;FC&#39;,&#39;PT&#39;,&#39;AR&#39;,&#39;SLG&#39;,&#39;ILZ&#39;,&#39;BE&#39;,&#39;BS&#39;,&#39;NG&#39;,&#39;CS&#39;,&#39;ROF&#39;); Think of INSERT with a subquery as a way of copying a table. You can select the rows and columns of a particular table that you want to copy into an existing or new table. UPDATE The UPDATE command is used to modify values in a table. The general format is UPDATE table SET column = scalar expression [, column = scalar expression] … [WHERE condition]; Permissible scalar expressions involve columns, scalar functions (see the section on scalar functions in this chapter), or constants. No aggregate functions are allowable. Updating a single row UPDATE can be used to modify a single row in a table. Suppose you need to revise your data after 200,000 shares of Minnesota Gold are sold. You would code the following: UPDATE stock SET stkqty = stkqty - 200000 WHERE stkcode = &#39;MG&#39;; Updating multiple rows Multiple rows in a table can be updated as well. Imagine the situation where several stocks change their dividend to £2.50. Then the following statement could be used: UPDATE stock SET stkdiv = 2.50 WHERE stkcode IN (&#39;FC&#39;,&#39;BS&#39;,&#39;NG&#39;); Updating all rows All rows in a table can be updated by simply omitting the WHERE clause. To give everyone a 5 percent raise, use UPDATE emp SET empsalary = empsalary*1.05; Updating with a subquery A subquery can also be used to specify which rows should be changed. Consider the following example. The employees in the departments on the fourth floor have won a productivity improvement bonus of 10 percent. The following SQL statement would update their salaries: UPDATE emp SET empsalary = empsalary*1.10 WHERE deptname IN (SELECT deptname FROM dept WHERE deptfloor = 4); DELETE The DELETE statement erases one or more rows in a table. The general format is DELETE FROM table [WHERE condition]; Delete a single record If all stocks with stkcode equal to “BE” were sold, then this row can be deleted using DELETE FROM stock WHERE stkcode = &#39;BE&#39;; Delete multiple records If all Australian stocks were liquidated, then the following command would delete all the relevant rows: DELETE FROM stock WHERE natcode in (SELECT natcode FROM nation WHERE natname = &#39;Australia&#39;); Delete all records All records in a table can be deleted by omitting the WHERE clause. The following statement would delete all rows if the entire portfolio were sold: DELETE FROM stock; This command is not the same as DROP TABLE because, although the table is empty, it still exists. Delete with a subquery Despite their sterling efforts in the recent productivity drive, all the employees on the fourth floor have been fired (the rumor is that they were fiddling the tea money). Their records can be deleted using DELETE FROM emp WHERE deptname IN (SELECT deptname FROM dept WHERE deptfloor = 4); SQL routines SQL provides two types of routines—functions and procedures—that are created, altered, and dropped using standard SQL. Routines add flexibility, improve programmer productivity, and facilitate the enforcement of business rules and standard operating procedures across applications. SQL function A function is SQL code that returns a value when invoked within an SQL statement. It is used in a similar fashion to SQL’s built-in functions. Consider the case of an Austrian firm with a database in which all measurements are in SI units (e.g., meters). Because its U.S. staff is not familiar with SI,13 it decides to implement a series of user-defined functions to handle the conversion. Here is the function for converting from kilometers to miles. CREATE FUNCTION km_to_miles(km REAL) RETURNS REAL RETURN 0.6213712*km; The preceding function can be used within any SQL statement to make the conversion. For example: SELECT km_to_miles(100); ❓ Skill builder Create a table containing the average daily temperature in Tromsø, Norway, then write a function to convert Celsius to Fahrenheit (F = C*1.8 + 32), and test the function by reporting temperatures in C and F. The temperatures in month order: -4.7, -4.1, -1.9, 1.1, 5.6, 10.1, 12.7, 11.8, 7.7, 2.9, -1.5, -3.7 SQL procedure A procedure is SQL code that is dynamically loaded and executed by a CALL statement, usually within a database application. We use an accounting system to demonstrate the features of a stored procedure, in which a single accounting transaction results in two entries (one debit and one credit). In other words, a transaction has multiple entries, but an entry is related to only one transaction. An account (e.g., your bank account) has multiple entries, but an entry is for only one account. Considering this situation results in the following data model. A simple accounting system The following are a set of steps for processing a transaction (e.g., transferring money from a checking account to a money market account): Write the transaction to the transaction table so you have a record of the transaction. Update the account to be credited by incrementing its balance in the account table. Insert a row in the entry table to record the credit. Update the account to be debited by decrementing its balance in the account table. Insert a row in the entry table to record the debit. Here is the code for a stored procedure to execute these steps. Note that the first line sets the delimiter to // because the default delimiter for SQL is a semicolon (;), which we need to use to delimit the multiple SQL commands in the procedure. The last statement in the procedure is thus END // to indicate the end of the procedure. DELIMITER // -- Define the input values CREATE PROCEDURE transfer ( IN `Credit account` INTEGER, IN `Debit account` INTEGER, IN Amount DECIMAL(9,2), IN `Transaction ID` INTEGER) LANGUAGE SQL DETERMINISTIC BEGIN -- Save the transaction details INSERT INTO transaction VALUES (`Transaction ID`, Amount, CURRENT_DATE); UPDATE account -- Increase the credit account SET acctbalance = acctbalance + Amount WHERE acctno = `Credit account`; INSERT INTO entry VALUES (`Transaction ID`, `Credit account`, &#39;cr&#39;); UPDATE account -- Decrease the debit account SET acctbalance = acctbalance - Amount WHERE acctno = `Debit account`; INSERT INTO entry VALUES (`Transaction ID`, `Debit account`, &#39;db&#39;); END // A CALL statement executes a stored procedure. The generic CALL statement for the preceding procedure is CALL transfer(cracct, dbacct, amt, transno); Thus, imagine that transaction 1005 transfers $100 to account 1 (the credit account) from account 2 (the debit account). The specific call is CALL transfer(1,2,100,1005); ❓ Skill builder Create the tables for the preceding data model, insert a some reows, and enter the code for the stored procedure. Now, test the stored procedure and query the tables to verify that the procedure has worked. Write a stored procedure to add details of a gift to the donation database (see exercises in Chapter 5). Trigger A trigger is a form of stored procedure that executes automatically when a table’s rows are modified. Triggers can be defined to execute either before or after rows are inserted into a table, when rows are deleted from a table, and when columns are updated in the rows of a table. Triggers can include virtual tables that reflect the row image before and after the operation, as appropriate. Triggers can be used to enforce business rules or requirements, integrity checking, and automatic transaction logging. Consider the case of recording all updates to the stock table (see Chapter 4). First, you must define a table in which to record details of the change. CREATE TABLE stock_log ( stkcode CHAR(3), old_stkprice DECIMAL(6,2), new_stkprice DECIMAL(6,2), old_stkqty DECIMAL(8), new_stkqty DECIMAL(8), update_stktime TIMESTAMP NOT NULL, PRIMARY KEY(update_stktime)); The trigger writes a record to stock_log every time an update is made to stock. Two virtual tables (old and new) have details of the prior and current values of stock price (old.stkprice and new.stkprice) and stock quantity (old.stkprice and new.stkprice). The INSERT statement also writes the stock’s identifying code and the time of the transaction. DELIMITER // CREATE TRIGGER stock_update AFTER UPDATE ON stock FOR EACH ROW BEGIN INSERT INTO stock_log VALUES (OLD.stkcode, OLD.stkprice, NEW.stkprice, OLD.stkqty, NEW.stkqty, CURRENT_TIMESTAMP); END // ❓ Skill builder Why is the primary key of stock_log not the same as that of stock? Universal Unique Identifier (UUID) A Universally Unique Identifier (UUID) is a generated number that is globally unique even if generated by independent programs on different computers. The probability that a UUID is not unique is close enough to zero to be negligible. More precisely, the probability of a duplicate within 103 trillion UUIDs is one in a billion. A UUID is a 128-bit number generated by combining a timestamp and the generating computers’s node id to create an identifier that it temporally and spatially different. A UUID is useful when you want to support different programs on different computers inserting rows in a distributed database. SELECT UUID() AS UUID_Value; Nulls—much ado about missing information Nulls are overworked in SQL because they can represent several situations. Null can represent unknown information. For example, you might add a new stock to the database, but lacking details of its latest dividend, you leave the field null. Null can be used to represent a value that is inapplicable. For instance, the employee table contains a null value in bossno for Alice because she has no boss. The value is not unknown; it is not applicable for that field. In other cases, null might mean “no value supplied” or “value undefined.” Because null can have multiple meanings, the client must infer which meaning is appropriate to the circumstances. Do not confuse null with blank or zero, which are values. In fact, null is a marker that specifies that the value for the particular column is null. Thus, null represents no value. The well-known database expert Chris Date has been outspoken in his concern about the confusion caused by nulls. His advice is that nulls should be explicitly avoided by specifying NOT NULL for all columns and by using codes to make the meaning of a value clear (e.g., “U” means “unknown,” “I” means “inapplicable,” and “N” means “not supplied”). Security Data are a valuable resource for nearly every organization. Just as an organization takes measures to protect its physical assets, it also needs to safeguard its electronic assets—its organizational memory, including databases. Furthermore, it often wants to limit the access of authorized users to particular parts of a database and restrict their actions to particular operations. Two SQL features are used to administer security procedures. A view, discussed earlier in this chapter, can restrict a client’s access to specified columns or rows in a table, and authorization commands can establish a user’s privileges. The authorization subsystem is based on the concept of a privilege—the authority to perform an operation. For example, a person cannot update a table unless they have been granted the appropriate update privilege. The database administrator (DBA) is a master of the universe and has the highest privilege. The DBA can perform any legal operation. The creator of an object, say a base table, has full privileges for that object. Those with privileges can then use GRANT and REVOKE, commands included in SQL’s data control language (DCL) to extend privileges to or rescind them from other users. GRANT The GRANT command defines a client’s privileges. The general format of the statement is GRANT privileges ON object TO users [WITH GRANT OPTION]; where “privileges” can be a list of privileges or the keyword ALL PRIVILEGES, and “users” is a list of user identifiers or the keyword PUBLIC. An “object” can be a base table or a view. The following privileges can be granted for tables and views: SELECT, UPDATE, DELETE, and INSERT. The UPDATE privilege specifies the particular columns in a base table or view that may be updated. Some privileges apply only to base tables. These are ALTER and INDEX. The following examples illustrate the use of GRANT: Give Alice all rights to the stock table. GRANT ALL PRIVILEGES ON stock TO alice; Permit the accounting staff, Todd and Nancy, to update the price of a stock. GRANT UPDATE (stkprice) ON stock TO todd, nancy; Give all staff the privilege to select rows from item. GRANT SELECT ON item TO PUBLIC; Give Alice all rights to view stk. GRANT SELECT, UPDATE, DELETE, INSERT ON stk TO alice; The WITH GRANT OPTION clause The WITH GRANT OPTION command allows a client to transfer his privileges to another client, as this next example illustrates: Give Ned all privileges for the item table and permit him to grant any of these to other staff members who may need to work with item. GRANT ALL PRIVILEGES ON item TO ned WITH GRANT OPTION; This means that Ned can now use the GRANT command to give other staff privileges. To give Andrew permission for select and insert on item, for example, Ned would enter GRANT SELECT, INSERT ON item TO andrew; REVOKE What GRANT granteth, REVOKE revoketh. Privileges are removed using the REVOKE statement. The general format of this statement is REVOKE privileges ON object FROM users; These examples illustrate the use of REVOKE. Remove Sophie’s ability to select from item. REVOKE SELECT ON item FROM sophie; Nancy is no longer permitted to update stock prices. REVOKE UPDATE ON stock FROM nancy; Cascading revoke When a REVOKE statement removes a privilege, it can result in more than one revocation. An earlier example illustrated how Ned used his WITH GRANT OPTION right to authorize Andrew to select and insert rows on item. The following REVOKE command REVOKE INSERT ON item FROM ned; automatically revokes Andrew’s insert privilege. The system catalog The system catalog describes a relational database. It contains the definitions of base tables, views, indexes, and so on. The catalog itself is a relational database and can be interrogated using SQL. Tables in the catalog are called system tables to distinguish them from base tables, though conceptually these tables are the same. In MySQL, the system catalog is called information_schema. Some important system tables in this schema are tables, and columns, and these are used in the following examples. Note that the names of the system catalog tables vary with RDBMS implementations, so while the following examples illustrate use of system catalog tables, it is likely that you will have to change the table names for other RDBMSs. The table TABLES contains details of all tables in the database. There is one row for each table in the database. Find the table(s) with the most columns. SELECT table_name, table_rows FROM information_schema.tables WHERE table_rows = (SELECT MAX(table_rows) FROM information_schema.tables); The COLUMN table stores details about each column in the database. What columns in what tables store dates? SELECT table_name, column_name FROM information_schema.columns WHERE DATA_TYPE = &#39;date&#39; ORDER BY table_name, column_name; As you can see, querying the catalog is the same as querying a database. This is a useful feature because you can use SQL queries on the catalog to find out more about a database. Natural language processing Infrequent inquirers of a relational database may be reluctant to use SQL because they don’t use it often enough to remain familiar with the language. While the QBE approach can make querying easier, a more natural approach is to use standard English. In this case, natural language processing (NLP) is used to convert ordinary English into SQL so the query can be passed to the relational database. The example in the table below shows the successful translation of a query to SQL. A natural language processor must translate a request to SQL and request clarification where necessary. An example of natural language processing English SQL generated for MS Access Which movies have won best foreign film sorted by year? SELECT DISTINCT [Year], [Title] FROM [Awards] INNER JOIN [Movies] ON [Movies].[Movie ID] = [Awards].[Movie ID] WHERE [Category]=‘Best Foreign Film’ and [Status]=‘Winner’ ORDER BY [Year] ASC; Connectivity and ODBC Over time and because of differing needs, an organization is likely to purchase RDBMS software from a variety of vendors. Also, in some situations, mergers and acquisitions can create a multivendor RDBMS environment. Consequently, the SQL Access Group developed SQL Call-Level Interface (CLI), a unified standard for remote database access. The intention of CLI is to provide programmers with a generic approach for writing software that accesses a database. With the appropriate CLI database driver, any RDBMS server can provide access to client programs that use the CLI. On the server side, the RDBMS CLI driver is responsible for translating the CLI call into the server’s access language. On the client side, there must be a CLI driver for each database to which it connects. CLI is not a query language but a way of wrapping SQL so it can be understood by a RDBMS. In 1996, CLI was adopted as an international standard and renamed X/Open CLI. Open database connectivity (ODBC) The de facto standard for database connectivity is Open Database Connectivity (ODBC), an extended implementation of CLI developed by Microsoft. This application programming interface (API) is cross-platform and can be used to access any RDBMS that has an ODBC driver. This enables a software developer to build and distribute an application without targeting a specific RDBMS. Database drivers are then added to link the application to the client’s choice of RDBMS. For example, a desktop app running under Windows can use ODBC to access an Oracle RDBMS running on a Unix box. There is considerable support for ODBC. Application vendors like it because they do not have to write and maintain code for each RDBMS; they can write one API. RDBMS vendors support ODBC because they do not have to convince application vendors to support their product. For database systems managers, ODBC provides vendor and platform independence. Although the ODBC API was originally developed to provide database access from MS Windows products, many ODBC driver vendors support Linux and Macintosh clients. Most vendors also have their own SQL APIs. The problem is that most vendors, as a means of differentiating their RDBMS, have a more extensive native API protocol and also add extensions to standard ODBC. The developer who is tempted to use these extensions threatens the portability of the database. ODBC introduces greater complexity and a processing overhead because it adds two layers of software. As the following figure illustrates, an ODBC-compliant application has additional layers for the ODBC API and ODBC driver. As a result, ODBC APIs can never be as fast as native APIs. ODBC layers Application ODBC API ODBC driver manager Service provider API Driver for RDBMS server RDBMS server Embedded SQL SQL can be used in two modes. First, SQL is an interactive query language and database programming language. SELECT defines queries; INSERT, UPDATE, and DELETE to maintain a database. Second, any interactive SQL statement can be embedded in an application program. This dual-mode principle is a very useful feature. It means that programmers need to learn one database query language, because the same SQL statements apply for both interactive queries and application statements. Programmers can also interactively examine SQL commands before embedding them in a program, a feature that can substantially reduce the time to write an application program. Because SQL is not a complete programming language, however, it must be used with a traditional programming language to create applications. Common complete programming languages, such as and Java, support embedded SQL. If you are need to write application programs using embedded SQL, you will need training in both the application language and the details of how it communicates with SQL. User-defined types Versions of SQL prior to the SQL-99 specification had predefined data types, and programmers were limited to selecting the data type and defining the length of character strings. One of the basic ideas behind the object extensions of the SQL standard is that, in addition to the normal built-in data types defined by SQL, user-defined data types (UDTs) are available. A UDT is used like a predefined type, but it must be set up before it can be used. The future of SQL Since 1986, developers of database applications have benefited from an SQL standard, one of the more successful standardization stories in the software industry. Although most database vendors have implemented proprietary extensions of SQL, standardization has kept the language consistent, and SQL code is highly portable. Standardization was relatively easy when focused on the storage and retrieval of numbers and characters. Objects have made standardization more difficult. Summary Structured Query Language (SQL), a widely used relational database language, has been adopted as a standard by ANSI and ISO. It is a data definition language (DDL), data manipulation language (DML), and data control language (DCL). A base table is an autonomous, named table. A view is a virtual table. A key is one or more columns identified as such in the description of a table, an index, or a referential constraint. SQL supports primary, foreign, and unique keys. Indexes accelerate data access and ensure uniqueness. CREATE TABLE defines a new base table and specifies primary, foreign, and unique key constraints. Numeric, string, date, or graphic data can be stored in a column. BLOB and CLOB are data types for large fields. ALTER TABLE adds one new column to a table or changes the status of a constraint. DROP TABLE removes a table from a database. CREATE VIEW defines a view, which can be used to restrict access to data, report derived data, store commonly executed queries, and convert data. A view is created dynamically. DROP VIEW deletes a view. CREATE INDEX defines an index, and DROP INDEX deletes one. Ambiguous references to column names are avoided by qualifying a column name with its table name. A table or view can be given a temporary name that remains current for a query. SQL has four data manipulation statements—SELECT, INSERT, UPDATE, and DELETE. INSERT adds one or more rows to a table. UPDATE modifies a table by changing one or more rows. DELETE removes one or more rows from a table. SELECT provides powerful interrogation facilities. The product of two tables is a new table consisting of all rows of the first table concatenated with all possible rows of the second table. Join creates a new table from two existing tables by matching on a column common to both tables. A subquery is a query within a query. A correlated subquery differs from a simple subquery in that the inner query is evaluated multiple times rather than once. SQL’s aggregate functions increase its retrieval power. GROUP BY supports grouping of rows that have the same value for a specified column. The REXEXP clause supports pattern matching. SQL includes scalar functions that can be used in arithmetic expressions, data conversion, or data extraction. Nulls cause problems because they can represent several situations—unknown information, inapplicable information, no value supplied, or value undefined. Remember, a null is not a blank or zero. The SQL commands, GRANT and REVOKE, support data security. GRANT authorizes a user to perform certain SQL operations, and REVOKE removes a user’s authority. The system catalog, which describes a relational database, can be queried using SELECT. SQL can be used as an interactive query language and as embedded commands within an application programming language. Natural language processing (NLP) and open database connectivity (ODBC) are extensions to relational technology that enhance its usefulness. Key terms and concepts Aggregate functions GROUP BY ALTER TABLE Index ANSI INSERT Base table ISO Complete database language Join Complete programming language Key Composite key Natural language processing (NLP) Connectivity Null Correlated subquery Open database connectivity (ODBC) CREATE FUNCTION Primary key CREATE INDEX Product CREATE PROCEDURE Qualified name CREATE TABLE Referential integrity rule CREATE TRIGGER REVOKE CREATE VIEW Routine Cursor Scalar functions Data control language (DCL) Security Data definition language (DDL) SELECT Data manipulation language (DML) Special registers Data types SQL DELETE Subquery DROP INDEX Synonym DROP TABLE System catalog DROP VIEW Temporary names Embedded SQL Unique key Foreign key UPDATE GRANT View References and additional readings Date, C. J. 2003. An introduction to database systems. 8th ed. Reading, MA: Addison-Wesley. Exercises Why is it important that SQL was adopted as a standard by ANSI and ISO? What does it mean to say “SQL is a complete database language”? Is SQL a complete programming language? What are the implications of your answer? List some operational advantages of a RDBMS. What is the difference between a base table and a view? What is the difference between a primary key and a unique key? What is the purpose of an index? Consider the three choices for the ON DELETE clause associated with the foreign key constraint. What are the pros and cons of each option? Specify the data type (e.g., DECIMAL(6,2)) you would use for the following columns: The selling price of a house A telephone number with area code Hourly temperatures in Antarctica A numeric customer code A credit card number The distance between two cities A sentence using Chinese characters The number of kilometers from the Earth to a given star The text of an advertisement in the classified section of a newspaper A basketball score The title of a CD The X-ray of a patient A U.S. zip code A British or Canadian postal code The photo of a customer The date a person purchased a car The time of arrival of an e-mail message The number of full-time employees in a small business The text of a speech The thickness of a layer on a silicon chip What is the difference between DROP TABLE and deleting all the rows in a table? Give some reasons for creating a view. When is a view created? Write SQL codes to create a unique index on firm name for the share table defined in Chapter 3. Would it make sense to create a unique index for PE ratio in the same table? What is the difference between product and join? What is the difference between an equijoin and a natural join? You have a choice between executing two queries that will both give the same result. One is written as a simple subquery and the other as a correlated subquery. Which one would you use and why? What function would you use for the following situations? Computing the total value of a column Finding the minimum value of a column Counting the number of customers in the customer table Displaying a number with specified precision Reporting the month part of a date Displaying the second part of a time Retrieving the first five characters of a city’s name Reporting the distance to the sun in feet Write SQL statements for the following: Let Hui-Tze query and add to the nation table. Give Lana permission to update the phone number column in the customer table. Remove all of William’s privileges. Give Chris permission to grant other users authority to select from the address table. Find the name of all tables that include the word sale. List all the tables created last year. What is the maximum length of the column city in the ClassicModels database? Why do you get two rows in the response? Find all columns that have a data type of SMALLINT. What are the two modes in which you can use SQL? Using the Classic Models database, write an SQL procedure to change the credit limit of all customers in a specified country by a specified amount. Provide before and after queries to show your procedure works. How do procedural programming languages and SQL differ in the way they process data? How is this difference handled in an application program? What is embedded SQL? Using the Classic Models database, write an SQL procedure to change the MSRP of all products in a product line by a specified percentage. Provide before and after queries to show your procedure works. The international system of units of measurement. SI is the from French Système International.↩︎ "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
